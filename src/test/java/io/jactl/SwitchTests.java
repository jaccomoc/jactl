/*
 * Copyright Â© 2022,2023 James Crawford
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.jactl;

import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

public class SwitchTests extends BaseTest {

  @Test public void switchExprs() {
    test("switch (1) {}", null);
    test("switch (1) { 1 -> 2 }", 2);
    testError("switch (1) { 1 -> 2; 1 -> 3 }", "literal match occurs multiple times");
    testError("switch (1) { 1,1 -> 2; 2 -> 3 }", "literal match occurs multiple times");
    testError("switch ('a') { 'abc','1' -> 2; '2','abc' -> 3 }", "literal match occurs multiple times");
    test("switch (1) { 1,2 -> 2 }", 2);
    testError("switch (1L) { 1,2 -> 2 }", "can never match");
    testError("switch (1L) { 1L,2 -> 2 }", "can never match");
    test("switch (1L) { 1L,2L -> 2 }", 2);
    test("def x = 1L; switch (x) { 1L,2 -> 2 }", 2);
    test("def x = 1L; switch (x) { 1,2 -> 2 }", null);
    testError("switch (1.0) { 1,2 -> 2 }", "can never match");
    testError("switch (1.0) { 1.0,2 -> 2 }", "can never match");
    testError("switch (1.0) { 1.00,2.0D -> 2 }", "can never match");
    test("switch (1.0) { 1.00,2.0 -> 3; 1.0 -> 2 }", 2);
    test("def x = 1.0; switch (x) { 1,2 -> 2 }", null);
    test("def x = 1.0; switch (x) { 1.0,2 -> 2 }", 2);
    test("def x = 1.00; switch (x) { 1.0,2 -> 2; 1.00 -> 3 }", 3);
    testError("var x = 1.0; switch (x) { 1,2 -> 2 }", "can never match");
    test("var x = 1.00; switch (x) { 1.0,2.0 -> 2; 1.00 -> 3 }", 3);
    testError("switch (1.0D) { 1,2 -> 2 }", "can never match");
    test("switch (1.0D) { 1.0D,2D -> 2 }", 2);
    test("def x = 1.0D; switch (x) { 1,2 -> 2 }", null);
    test("def x = 1.0D; switch (x) { 1.0D,2D -> 2 }", 2);
    testError("var x = 1.0D; switch (x) { 1,2 -> 2 }", "can never match");
    test("switch (3) { 1,2 -> 2 }", null);
    test("def it = 1; switch{ 1 -> 2 }", 2);
    test("def it = 1; switch{ 1,2,3 -> 2 }", 2);
    test("def it = 4; switch{ 1,2,3 -> 2 }", null);
    testError("int x = 1; switch (x) { 1,'abc',2 -> 2 }", "can never match type string");
    test("def x = 1; switch (x) { 1,'abc',2 -> 2 }", 2);
    test("def it = 1; switch{ 1,'abc',2 -> 2 }", 2);
    test("def x = 3; switch (x) { 1,'abc',2 -> 2 }", null);
    test("def it = 3; switch{ 1,'abc',2 -> 2 }", null);
    test("def x = 'A'; switch (x) { 1,'abc',2 -> 2; 65 -> 'a'; _ -> null }", null);
    test("def it = 'A'; switch{ 1,'abc',2 -> 2\n65 -> 'a'; _ -> null }", null);
    testError("switch ('A') { 1,'abc',2 -> 2; 65 -> 'a' }",  "can never match");
    testError("switch ('AB') { 1,'abc',2 -> 2\n65 -> 'a' }", "can never match");
    testError("switch (1) { default -> 3; default -> 4 }", "cannot have multiple 'default'");
    test("List x = []; switch (x) { [] -> 1 }", 1);
    test("def x = []; switch (x) { [] -> 1 }", 1);
    test("switch([]) { [] -> 1 }", 1);
    test("switch([1,2,3]) { [1,2],[1,2,3] -> 1 }", 1);
    test("def x = [1,2,3]; switch (x) { [1,2],[1,2,4] -> 1; [1,2,3] -> 2 }", 2);
    test("List x = [1,2,3]; switch (x) { [1,2],[1,2,4] -> 1; [1,2,3] -> 2 }", 2);
    testError("List x = [1,2,3]; switch (x) { [1,2],[1,2,3] -> 1; [1,2,3] -> 2 }", "literal match occurs multiple times");
    test("def i = 2; switch (i) { 1 -> 1; default -> 2 }", 2);
    testError("switch(0) { 0 || 1 || 2 -> 2\n3 -> 4\ndefault -> 5 }", "unexpected token");
    testError("switch(0) { 0 or 1 or 2 -> 2; 3 -> 4; default -> 5 }", "unexpected token 'or'");
    test("def it = 'abc'; switch{ 'abc' -> 1; default -> 2 }", 1);
    testError("switch{ 'abc' -> 1; default -> 2 }", "unknown variable 'it'");
    test("def it = 'abc'; switch (it[0]) { 'a' -> 1; default -> 2 }", 1);
    test("def it = 'abc'; switch (it[0]) { 'a' -> it; default -> 2 }", "a");
    test("def it = 'abc'; def x = switch (it[0]) { 'a' -> it; default -> 2 }; it + x", "abca");
    test("switch([1,2,3].map{it+it}) { [2,4,6] -> 3; default -> 0 }", 3);
    test("switch([1,2,3] as int[]) { [1,2,3] -> 2; default -> 0 }", 2);
    test("def x = [1,2,3].map{it+it}; switch (x) { [2,4,6] -> 3; default -> 0 }", 3);
    test("def x = [1,2,3] as int[]; switch (x) { [1,2,3] -> 2; default -> 0 }", 2);
    test("def it = [1,2,3] as int[]; switch{ [1,2,3] -> 2; default -> 0 }", 2);
    test("def it = [1,2,3] as int[]; switch\n{\n [\n1,\n2,\n3\n]\n ->\n 2\ndefault\n ->\n 0\n }", 2);
    testError("int x = 2\nswitch (x) {\n  1,2 -> x\n  'abc' -> x\n}", "can never match type string");
  }

  @Test public void switchLiterals() {
    test("switch(null) { null -> 1; default -> 2}", 1);
    test("def x = null; switch(x) { null -> 1; default -> 2}", 1);
    test("switch (1L) { 1L,2L,3L -> 2; _ -> 3 }", 2);
    test("switch (1L) { 1L,2L if true,3L -> 2 }", 2);
    testError("switch (1L) { 1L if true,2L if true,3 -> 2 }", "can never match");
    test("switch (1L) { 1L if true,2L if true,3L -> 2 }", 2);
    test("switch (1) { 2,3,4 -> 2; 1,5,6 -> 7; 10,20 -> 20 }", 7);
    test("def x = 1L; switch (x) { 1L,2,3 -> 2; _ -> 3 }", 2);
    test("def x = 1L; switch (x) { 1,2 if true,3 -> 2 }", null);
    test("def x = 1L; switch (x) { 1L if true,2 if true,3 -> 2 }", 2);
    test("int x = 3; switch (x) { 1 if true,2 if true,3 -> 2 }", 2);
    test("long x = 1L; switch (x) { 1L if true,2L if true,3L -> 2 }", 2);
    test("double x = 1D; switch (x) { 1D if true,2D if true,3D -> 2 }", 2);
    test("Decimal x = 1.0; switch (x) { 1.0 if true,2.0 if true,3.0 -> 2 }", 2);
    test("def x = 1; switch (x) { 2,3,4 -> 2; 1,5,6 -> 7; 10,20 -> 20 }", 7);
    test("switch (1) { 2,3,4 -> 2; 1,5,6 -> 7; 10,20 -> 20 }", 7);
    test("int x = 1; switch (x) { 2,3,4 -> 2; 1,5,6 -> 7; 10,20 -> 20 }", 7);
    test("def i = 0; def x = 1; switch (x) { 2,3,4 -> { i++; 2 }; 1,5,6 -> {i++; 7}; 10,20 -> 20 }", 7);
    test("def i = 0; def x = 1; switch (x) { 2,3,4 -> { i++; 2 }; 1,'abc',5,6 -> {i++; 7}; 10,20 -> 20 }", 7);
    test("def i = 0; def x = 1.0D; switch (x) { 2,3,4 -> { i++; 2 }; 1D,5,6 -> {i++; 7}; 20 -> 20 }", 7);
    test("def i = 0; def x = 1.0D; switch (x) { 2,3,4 -> { i++; 2 }; 1,'abc',5,6 -> {i++; 7}; _ -> 99 }", 99);
    test("def i = 0; def x = 1.0; switch (x) { 2,3,4 -> { i++; 2 }; 1.0,5,6 -> {i++; 7}; 20 -> 20 }", 7);
    test("def i = 0; def x = 1.0; switch (x) { 2,3,4 -> { i++; 2 }; 1.0,'abc',5,6 -> {i++; 7}; _ -> 99 }", 7);
    testError("def i = 0; double x = 1.0D; switch (x) { 2.0 -> { i++; 2 }; 1D -> {i++; 7}; 20D -> 20 }", "can never match");
    test("def i = 0; def x = 1.0D; switch (x) { 1,2,3,4 -> { i++; 2 }; 1.0D,5,6 -> {i++; 7}; 20 -> 20 }", 7);
    testError("def i = 0; Decimal x = 1.0; switch (x) { 2D -> { i++; 2 }; 1D -> {i++; 7}; 20D -> 20 }", "can never match");
    test("String x = 'abc'; switch (x) { '123','xyz' -> 1; 'abc','xxx' -> 2; _ -> 3 } ", 2);
    test("def x = 'abc'; switch (x) { '123','xyz' -> 1; 'abc','xxx' -> 2; _ -> 3 } ", 2);
    test("def x = 'abc'; switch (x) { '123','xyz' -> 1; 1,2L,'abc','xxx' -> 2; _ -> 3 } ", 2);
    testError("String x = 'a'; switch (x) { '123','xyz' -> 1; 1,2,'abc','xxx' -> 2; _ -> 3 } ", "can never match");
    test("def x = 'abc'; switch (x) { '123','xyz' -> 1; 1,2L if true,'abc','xxx' -> 2; _ -> 3 } ", 2);
    test("def x = 'abc'; switch (x) { '123',null,'xyz' -> 1; 1,2L if true,'abc','xxx' -> 2; _ -> 3 } ", 2);
    test("def x = null; switch (x) { '123',null,'xyz' -> 1; 1,2L if true,'abc','xxx' -> 2; _ -> 3 } ", 1);
    test("def x = (byte)'a'; switch (x) { (byte)1 -> 1; (byte)'a' -> 2 }", 2);
    testError("def x = (byte)'a'; switch (x) { (byte)1 -> 1; (byte)'abc' -> 2 }", "cannot be cast to byte");
    testError("def x; switch (x) { (int)1 -> 1; (int)'abc' -> 2 }", "cannot be cast");
    testError("def x; switch (x) { (int)1 -> 1; (long)'abc' -> 2 }", "cannot be cast");
    test("def x; switch (x) { null -> 3; (String)'abc' -> 2 }", 3);
    test("def x; switch (x) { (String)'abc' -> 2 }", null);
    test("def x = 'abc'; switch (x) { (String)'abc' -> 2 }", 2);
    test("String x = 'abc'; switch (x) { (String)'abc' -> 2 }", 2);
    test("def x = 'abc'; switch (x) { 1,2,3,4 -> 1; long -> 2; 'a','b','abc' -> 3}", 3);
  }

  @Test public void switchWithRecursion() {
    test("def f(it) { switch { [a,b] -> f(a)+f(b); [c] -> c; d -> d } }; f([[1,2],[3]])", 6);
    test("def f(it) { switch { [a,b] -> f(a)+f(b); [c] -> c; d -> d } }; f([[1,2],[[5],[1,2]]])", 11);
  }

  @Test public void switchWithExpansions() {
    test("def i = 1; switch (1) { $i -> true; _ -> false }", true);
    test("def i = 1; switch ([1]) { [$i] -> true; _ -> false }", true);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [$i,2,a] -> a; _ -> false }", 3);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [$i,2,a] -> a; [1,2,3] -> 7; _ -> false }", 3);
    testError("def i = 1; int[] x = [1,2,3]; switch (x) { [_,_,_] -> 9; [$i,2,a] -> a; _ -> false }", "covered by a previous pattern");
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [$i,${i*2},a] -> a; _ -> false }", 3);
    testError("def i = 1; int[] x = [1,2,3]; switch (x) { [$i++,${i*2},a] -> a; _ -> false }", "unexpected token");
    test("def i = 1; int[] x = [1,2,1]; switch (x) { [a,${i*2},${a}] -> a*3; _ -> false }", 3);
    test("def i = 1; int[] x = [1,2,1]; switch (x) { [a,${i*2},$a] -> a; _ -> false }", 1);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${i+a},${3*a}] -> 2*a+i; _ -> false }", 3);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${2*a},${3*a}] -> 2*a+i; _ -> false }", 3);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${2*a; return 7},${3*a}] -> 2*a+i; _ -> false }", 7);
    test("def i = 1; int[] x = [1,2,2]; switch (x) { [a,${++a},a] -> a; _ -> false }", 2);  // hard to prevent mutation so have to allow
    test("def i = 1; int[] x = [1,2,2]; switch (x) { [a,${sleep(0,++a)+ sleep(0,0)},${sleep(0,a)}] -> a; _ -> false }", 2);  // hard to prevent mutation so have to allow
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${def i = 2; i*a},${3*a}] -> 2*a+i; _ -> false }", 3);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${def a = 2; a},${3*a}] -> 2*a+i; _ -> false }", 3);
    testError("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${switch(a){a->a}*2},${3*a}] -> 2*a+i; _ -> false }", "'a' shadows another variable");
    testError("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${switch(a){i->i}*2},${3*a}] -> 2*a+i; _ -> false }", "'i' shadows another variable");
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${switch(a){j->j}*2},${3*a}] -> 2*a+i; _ -> false }", 3);
    test("def i = 1; int[] x = [1,2,3]; switch (x) { [a,${switch(a){$a->a}*2},${3*a}] -> 2*a+i; _ -> false }", 3);
  }

  @Test public void switchWithRegex() {
    test("switch('abc') { /a/r -> 1 }", 1);
    test("switch('abc') { /a/r -> 1; default -> 2 }", 1);
    test("switch('abc') { /z/r -> 1; default -> 2 }", 2);
    test("def it = 'abc'; switch{ /a/r -> 1; default -> 2 }", 1);
    test("def it = 'abc'; switch{ /a(.)c/r -> $1; default -> 2 }", "b");
    test("def it = 'abc'; switch{ /a(.)c/r if false, 'abc'-> $1; default -> 2 }", null);
    test("def it = ['abc']; switch{ /a(.)c/r -> $1; default -> 2 }", 2);
    testError("switch (['abc']) { /a(.)c/r -> $1; default -> 2 }", "can never match");
    testError("def it = 'abc'; switch{ /a(.)c/ -> $1; default -> $1 }", "reference to regex capture variable");
    test("switch('abc') { /a/ -> 1 }", null);
    test("def x = 'bc'; switch('abc') { /a$x/ -> 1 }", 1);
    testError("switch (['abc']) { /a(.)c/ -> $1; default -> 2 }", "no regex match");
    test("switch (['abc','xyz']) { [_,2] -> null; [/^a/r, /z$/r] -> true; _ -> false }", true);
    test("switch (['abc','xyz']) { [/^a(.)/r, /(.)z$/r] -> $1 + $1; _ -> false }", "yy");
    test("switch (['abc','xyz']) { [/^a(.)/r, /(.)z$/r] -> $1 + it[0]; _ -> false }", "yabc");
    test("switch (['abc','xyz']) { [/^a(.)/r, 3],[_,a] -> a + $1; _ -> false }", "xyznull");
  }

  @Test public void switchOnType() {
    test("switch (1) { int -> 2 }", 2);
    testError("String x = switch (1) { int -> 2 }", "cannot convert object of type int to string");
    testError("switch (1) { String -> 2 }", "can never match type string");
    testError("switch (1) { String,int -> 2 }", "can never match type string");
    test("def x = 1; switch (x) { String,int -> 2 }", 2);
    test("def x = 1; switch (x) { String -> 2; int -> 3 }", 3);
    test("def x = 'abc'; switch (x) { String,1 -> 2; int -> 3 }", 2);
    test("def x = 'abc'; switch (x) { long,1 -> 2; int,'abc' -> 3 }", 3);
    test("def x = []; switch (x) { String -> 2\n int -> 3\n List -> 4\n default -> 5 }", 4);
    test("def x = [:]; switch (x) { String -> 2\n Map,int -> 3; List -> 4\n default -> 5 }", 3);
    testError("int x = 3; switch(x) { long -> 4; default -> 2}", "can never match type long");
    testError("int x = 3; switch(x) { long i -> i; default -> 2}", "can never match type long");
    test("def x = 3; switch(x) { long i -> i; int i -> i*i; default -> 2} == 9", true);
    test("switch(null) { long -> 1; int -> 2; String -> 3; def -> 4 }", 4);
    test("def x = null; switch(x) { long -> 1; int -> 2; String -> 3; def -> 4 }", 4);
    testError("List x = null; switch(x) { long -> 1; int -> 2; String -> 3; def -> 4 }", "can never match type long");
    test("def x = 'abc' as byte[]; switch(x) { long -> 1; int -> 2; String -> 3; def -> 4 }", 4);
  }

  @Test public void patternCoverages() {
    testError("List a = [1,2]; switch(a) { [x,y],[_,x] -> x }", "covered by a previous");
    test("List a = [1,2]; switch(a) { [x,y] if x == 1,[_,x] -> x }", 1);
    testError("List a = ['aa','bb','cc']; switch(a) { [_,i,'cc'] -> i; [_,i,'cc'] -> 7 }", "covered by a previous");
    testError("def x = 1; switch (x) { String,1 -> 2; int,'abc' -> 3 }", "covered by a previous");
    test("def a = [1,2]; switch(a) { [1,2],[_,z] -> z }", null);
    testError("def a; switch(a) { [_,i,'cc'] -> i; [_,[x:i],'cc'] -> 7 }", "covered by a previous");
    test("def a=[1,[x:3]]; switch(a) { [_,i,'cc'] -> i; [_,[x:i]] -> i }", 3);
    test("def a=[1,[x:3]]; switch(a) { [_,int i] -> i; [_,[x:i]] -> i }", 3);
  }

  @Test public void switchOnMap() {
    test("switch ([:]) { Map -> 1; default -> 2 }", 1);
    test("switch ([:]) { Map x -> x; default -> 2 }", Utils.mapOf());
    test("switch ([:]) { [:] -> 1; default -> 2 }", 1);
    test("switch ([:]) { [a:_] -> 1; default -> 2 }", 2);
    test("switch ([:]) { [a:_,*] -> 1; default -> 2 }", 2);
    test("switch ([a:1]) { [a:1] -> 1; default -> 2 }", 1);
    testError("switch ([a:1]) { [_] -> 1; default -> 2 }", "can never match type");
    test("switch ([a:1]) { [a:_] -> 1; default -> 2 }", 1);
    test("switch ([a:1]) { [b:_] -> 1; default -> 2 }", 2);
    testError("switch ([a:1]) { [*] -> 1; default -> 2 }", "can never match type list");
    test("switch ([a:1,b:2]) { [a:_] -> 1; default -> 2 }", 2);
    test("switch ([a:1,b:2]) { [a:_,b:_] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [a:_,*] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [b:_,*] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [*,b:_] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [a:1,*] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [a:1,b:_] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [a:1,*,b:_] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2]) { [a:2,*,b:_] -> 1; default -> 2 }", 2);
    test("switch ([a:1,b:2]) { [a:1,*,b:_] -> 1; _ -> 2 }", 1);
    test("switch ([a:1,b:2]) { [a:2,*,b:_] -> 1; _ -> 2 }", 2);
    test("switch ([a:1,b:2,c:3]) { [a:1,*,b:_] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:2,c:3]) { [a:1,b:_] -> 1; default -> 2 }", 2);
    test("switch ([a:1,b:[2],c:3]) { [a:1,b:[_],*] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:[2,3],c:3]) { [a:1,b:[_,_],*] -> 1; default -> 2 }", 1);
    test("switch ([a:1,b:[2,3],c:3]) { [a:1,b:[x,y],*] -> x+y; default -> 2 }", 5);
    test("switch ([a:1,b:[2,3],c:3]) { [a:1,b:[int x,y],*] -> x+y; default -> 2 }", 5);
    test("switch ([a:1,b:[2,3],c:3]) { [a:1,b:[int x,long y],*] -> x+y; default -> 2 } == 2", true);
    test("switch ([a:1,b:[2,3],c:3]) { [a:1,b:x,*] -> x; default -> 2 }", Utils.listOf(2,3));
    test("switch ([a:1,b:[z:4],c:3]) { [a:1,b:x,*] -> x; default -> 2 }", Utils.mapOf("z",4));
    test("def val =[:]; switch(val) { Map -> 1; default -> 2 }", 1);
    test("def val =[:]; switch(val) { Map x -> x; default -> 2 }", Utils.mapOf());
    test("def val =[:]; switch(val) { [:] -> 1; default -> 2 }", 1);
    test("def val =[:]; switch(val) { [a:_] -> 1; default -> 2 }", 2);
    test("def val =[:]; switch(val) { [a:_,*] -> 1; default -> 2 }", 2);
    test("def val =[a:1]; switch(val) { [a:1] -> 1; default -> 2 }", 1);
    test("def val =[a:1]; switch(val) { [i] -> i; default -> 2 }", 2);
    test("def val = 1; switch(val) { [i] -> i; default -> 2 }", 2);
    test("def val =[1]; switch(val) { [a:i] -> i; default -> 2 }", 2);
    test("def val =[a:1]; switch(val) { [_] -> 1; default -> 2 }", 2);
    test("def val =[a:1]; switch(val) { [a:_] -> 1; default -> 2 }", 1);
    test("def val =[a:1]; switch(val) { [b:_] -> 1; default -> 2 }", 2);
    test("def val =[a:1]; switch(val) { [*] -> 1; default -> 2 }", 2);
    test("def val =[a:1,b:2]; switch(val) { [a:_] -> 1; default -> 2 }", 2);
    test("def val =[a:1,b:2]; switch(val) { [a:_,b:_] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [a:_,*] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [b:_,*] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [*,b:_] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [a:1,*] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [a:1,b:_] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [a:1,*,b:_] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [a:2,*,b:_] -> 1; default -> 2 }", 2);
    test("def val =[a:1,b:2]; switch(val) { [a:1,*,b:_] -> 1; _ -> 2 }", 1);
    test("def val =[a:1,b:2]; switch(val) { [a:1,*,b:x] -> x*x; default -> 0 }", 4);
    test("def val =[a:1,b:2,c:3]; switch(val) { [a:1,*,b:_] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:2,c:3]; switch(val) { [a:1,b:_] -> 1; default -> 2 }", 2);
    test("def val =[a:1,b:[2],c:3]; switch(val) { [a:1,b:[_],*] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:[2,3],c:3]; switch(val) { [a:1,b:[_,_],*] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:[d:4],c:3]; switch(val) { [a:1,b:Map,*] -> 1; default -> 2 }", 1);
    test("def val =[a:1,b:[d:4],c:3]; switch(val) { [a:1,b:[d:x],*] -> x; default -> 2 }", 4);
    test("def val =[a:1,b:[2,3],c:3]; switch(val) { [a:1,b:[x,y],*] -> x+y; default -> 2 }", 5);
    test("def val =[a:1,b:[2,3],c:3]; switch(val) { [a:1,b:[int x,y],*] -> x+y; default -> 2 }", 5);
    test("def val =[a:1,b:[2,3],c:3]; switch(val) { [a:1,b:[int x,long y],*] -> x+y; default -> 2 } == 2", true);
    test("def val =[a:1,b:[2,3],c:3]; switch(val) { [a:1,b:x,*] -> x; default -> 2 }", Utils.listOf(2,3));
    test("def val =[a:1,b:[z:4],c:3]; switch(val) { [a:1,b:x,*] -> x; default -> 2 }", Utils.mapOf("z",4));
    test("def val =[a:1,b:[z:4],c:3]; switch(val) { ['a':1,b:x,*] -> x; default -> 2 }", Utils.mapOf("z",4));
    test("def val =['a a':1,b:[z:4],c:3]; switch(val) { ['a a':1,b:x,*] -> x; default -> 2 }", Utils.mapOf("z",4));
    test("Map[] x = [[i:3],[i:4]]; switch (x) { [[i:3],[i:3]] -> 4; [[i:3],[i:4]] -> 3; _ -> null }", 3);
    test("Map[] x = [[i:3],[i:4]]; switch (x) { [_,[i:3]] -> 4; [[i:3],_] -> 3; _ -> null }", 3);
    test("Map[] x = [[i:3],[i:4]]; switch (x) { [_,[i:3]] -> 3; [[i:3],a] -> a; _ -> null } == [i:4]",true);
    test("def x = [[i:3],[i:4]] as Map[]; switch (x) { [[i:3],[i:3]] -> 4; [[i:3],[i:4]] -> 3; _ -> null }", 3);
    test("def x = [[i:3],[i:4]] as Map[]; switch (x) { [[i:3],[i:3]] -> 4; [_,[i:4]] -> 3; _ -> null }", 3);
    test("def x = [[i:3],[i:4]] as Map[]; switch (x) { [[i:3],[i:3]] -> 4; [a,[i:4]] -> a; _ -> null } == [i:3]", true);
    testError("Map[][] x = [[[i:3]], [[i:4]]]; switch (x) { [_,[i:3]] -> 3; [[i:3],a] -> a; _ -> null }", "can never match");
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3]],[a]] -> a; _ -> null } == [i:4]", true);
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3L]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3D]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3.0]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3]],_] -> 4; _ -> null }", 4);
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4]", true);
    test("Map[][] x = [[[i:3]],[[i:4]]]; switch (x) { [[_],[[i:3]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4]", true);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3]],[a]] -> a; _ -> null } == [i:4]", true);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3L]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3D]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3.0]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [[[i:3]],_] -> 4; _ -> null }", 4);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4]", true);
    test("def x = [[[i:3]],[[i:4]]] as Map[][]; switch (x) { [[_],[[i:3]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4]", true);
    test("Map[] x = [[i:3,j:7],[i:4,j:9]]; switch (x) { [[i:3,*],[i:3,*]] -> 4; [[i:3,*],[i:4,*]] -> 3; _ -> null }", 3);
    test("Map[] x = [[i:3,j:7],[i:4,j:9]]; switch (x) { [_,[i:3,*]] -> 4; [[i:3,*],_] -> 3; _ -> null }", 3);
    test("Map[] x = [[i:3,j:7],[i:4,j:9]]; switch (x) { [_,[i:3,*]] -> 3; [[i:3,*],a] -> a; _ -> null } == [i:4,j:9]",true);
    test("def x = [[i:3,j:7],[i:4,j:9]] as Map[]; switch (x) { [[i:3,*],[i:3,*]] -> 4; [[i:3,*],[i:4,*]] -> 3; _ -> null }", 3);
    test("def x = [[i:3,j:7],[i:4,j:9]] as Map[]; switch (x) { [[i:3,*],[i:3,*]] -> 4; [_,[i:4,*]] -> 3; _ -> null }", 3);
    test("def x = [[i:3,j:7],[i:4,j:9]] as Map[]; switch (x) { [[i:3,*],[i:3,*]] -> 4; [a,[i:4,*]] -> a; _ -> null } == [i:3,j:7]", true);
    testError("Map[][] x = [[[i:3,j:7]], [[i:4,j:9]]]; switch (x) { [_,[i:3,*]] -> 3; [[i:3,*],a] -> a; _ -> null }", "can never match");
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3,*]],[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3L,*]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3D,*]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3.0,*]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3,*]],_] -> 4; _ -> null }", 4);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,*]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3,*]],[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3L,*]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3D,*]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3.0,*]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [[[i:3,*]],_] -> 4; _ -> null }", 4);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,*]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("Map[] x = [[i:3,j:7],[i:4,j:9]]; switch (x) { [[i:3,j:7],[i:3,j:7]] -> 4; [[i:3,j:7],[i:4,j:9]] -> 3; _ -> null }", 3);
    test("Map[] x = [[i:3,j:7],[i:4,j:9]]; switch (x) { [_,[i:3,j:7]] -> 4; [[i:3,j:7],_] -> 3; _ -> null }", 3);
    test("Map[] x = [[i:3,j:7],[i:4,j:9]]; switch (x) { [_,[i:3,j:7]] -> 3; [[i:3,j:7],a] -> a; _ -> null } == [i:4,j:9]",true);
    test("def x = [[i:3,j:7],[i:4,j:9]] as Map[]; switch (x) { [[i:3,j:7],[i:3,j:7]] -> 4; [[i:3,j:7],[i:4,j:9]] -> 3; _ -> null }", 3);
    test("def x = [[i:3,j:7],[i:4,j:9]] as Map[]; switch (x) { [[i:3,j:7],[i:3,j:7]] -> 4; [_,[i:4,j:9]] -> 3; _ -> null }", 3);
    test("def x = [[i:3,j:7],[i:4,j:9]] as Map[]; switch (x) { [[i:3,j:7],[i:3,j:7]] -> 4; [a,[i:4,j:9]] -> a; _ -> null } == [i:3,j:7]", true);
    testError("Map[][] x = [[[i:3,j:7]], [[i:4,j:9]]]; switch (x) { [_,[i:3,j:7]] -> 3; [[i:3,j:7],a] -> a; _ -> null }", "can never match");
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3,j:7]],[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3L,j:7]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3D,j:7]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3.0,j:7]],[a]] -> a; _ -> null } == null", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3,j:7]],_] -> 4; _ -> null }", 4);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("Map[][] x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3,j:7]],[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3L,j:7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3D,j:7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3.0,j:7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3,j:7]],_] -> 4; _ -> null }", 4);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]] as Map[][]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3,j:7]],[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3L,j:7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3D,j:7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3.0,j:7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [[[i:3,j:7]],_] -> 4; _ -> null }", 4);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [_,[a]] -> a; _ -> null } == [i:4,j:9]", true);
    test("def x = [[[i:3,j:7]],[[i:4,j:9]]]; switch (x) { [[_],[[i:3,j:7]]] -> 3; [_,[Map a]] -> a; _ -> null } == [i:4,j:9]", true);
    testError("def val =['a a':1,b:[z:4],c:3]; def x = 'b'; switch(val) { [\"${'abc'[0]} a\":1,\"$x\":x,*] -> x; default -> 2 }", "unexpected token");
  }

  @Test public void switchOnList() {
    test("switch ([]) { [*] -> true; _ -> false}", true);
    test("def x = []; switch (x) { [*] -> true; _ -> false}", true);
    test("switch ([1]) { [*] -> true; _ -> false}", true);
    test("def x = [1]; switch (x) { [*] -> true; _ -> false}", true);
    test("switch ([1,2]) { [*] -> true; _ -> false}", true);
    test("def x = [1,2]; switch (x) { [*] -> true; _ -> false}", true);
    test("def x = 1; switch (x) { [a,b] -> 1; _ -> 2 }", 2);
    testError("switch('abc') { ['a','b','c'] -> true; default -> false }", "can never match type list");
    test("switch ([]) { [] -> 1; default -> 2 }", 1);
    test("switch ([1]) { [] -> 1; default -> 2 }", 2);
    test("switch ([1]) { [1] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [1,2] -> 1; default -> 2 }", 1);
    test("switch ([1]) { [_] -> 1; default -> 2 }", 1);
    test("switch ([1]) { [*] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [_] -> 1; default -> 2 }", 2);
    test("switch ([1,2]) { [_,*] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [*, _] -> 1; default -> 2 }", 1);
    test("switch ([1,2,3]) { [_,_,_] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [_, *, _] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [*, 3] -> 1; default -> 2 }", 2);
    test("switch ([1,2]) { [*, 2] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [1,*] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [1,*,_] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [1,*,2] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [1,_,2] -> 1; default -> 2 }", 2);
    test("switch ([1,2]) { [2,*,_] -> 1; default -> 2 }", 2);
    test("switch ([1,2]) { [_,2] -> 1; default -> 2 }", 1);
    test("switch ([1,2]) { [[_],2] -> 1; [_,*] -> 3; default -> 2 }", 3);
    test("def a = [1,2]; switch (a) { [[_],2] -> 1; [_,*] -> 3; default -> 2 }", 3);
    test("switch ([[1],2]) { [[_],2] -> 1; default -> 2 }", 1);
    test("switch ([[1],2]) { [[1],2] -> 1; default -> 2 }", 1);
    test("switch ([1,2,3]) { [_,2,_] -> 1; default -> 2 }", 1);
    testError("switch ([1,2,3]) { _ -> 1; default -> 2 }", "default case is never applicable");
    testError("switch ([1,2,3]) { _ -> 1; _ -> 2 }", "unreachable switch case");
    testError("switch ([1,2,3]) { _ -> 1; [1,2,3] -> 2 }", "unreachable switch case");
    test("switch ([1,2,3]) { [1,2] -> 2; _ -> 1 }", 1);
    test("switch ([1,2,3]) { [1,2] -> 2; [1,2,4],[1,2,3] -> 1 }", 1);
    test("switch ([1,2,3]) { [1,2] -> 2; [_],[_,_,_] -> 1 }", 1);
    test("switch ([1,2,3]) { [1,2] -> 2; [int],[_,int,_] -> 1 }", 1);
    testError("switch ([1,2,3]) { [1,2] -> 2; _,_ -> 1 }", "unreachable");
    test("switch ([1,2,3]) { [1,2,int] -> 2; _ -> 1 }", 2);
    test("switch ([1,2,3]) { [_,2,int] -> 2; _ -> 1 }", 2);
    test("switch ([1,[2,'abc'],3]) { [_,[_,String],int] -> 2; _ -> 1 }", 2);
    test("switch ([1,[2,'abc'],3]) { [*,[2,String],int] -> 2; _ -> 1 }", 2);
    test("switch ([1,[2,'abc'],3]) { [*,[*,String],int] -> 2; _ -> 1 }", 2);
    test("switch ([1,[2,\"${'abc'}\"],3]) { [*,[*,String],int] -> 2; _ -> 1 }", 2);
    test("switch ([1,[2,\"${'abc'}\"],3]) { [*,[*,String s],int] -> s; _ -> 1 }", "abc");
    testError("List x = [1,2,3]; switch(x) { i -> i; [1,4,3] -> 7 }", "unreachable switch case");
    testError("List x = [1,2,3]; switch(x) { List i -> i; [1,4,3] -> 7 }", "unreachable switch case");
    test("List x = [1,2,3]; switch(x) { i -> i }", Utils.listOf(1,2,3));
    testError("List x = [1,2,3]; switch(x) { int i -> i }", "type of binding variable not compatible");
    test("List x = [1,2,3]; switch(x) { List i -> i }", Utils.listOf(1,2,3));
    test("List x = [1,2,3]; switch(x) { def i -> i }", Utils.listOf(1,2,3));
    test("List x = [1,2,3]; switch(x.size()) { int i -> i }", 3);
    testError("List x = [1,2,3]; switch(x.size()) { long i -> i }", "can never match type long");
    test("List x = [1,2,3]; switch(x) { [1,i,3] -> i; [1,4,4] -> 7 }", 2);
    test("List x = [1,2,3]; switch(x) { [1,int i,3] -> i; [1,4,4] -> 7 }", 2);
    test("List x = [1,2,3]; switch(x) { [1,def i,3] -> i; [1,4,4] -> 7 }", 2);
    test("List x = [1,2,2]; switch(x) { [1,i,i] -> i; [1,4,3] -> 7 }", 2);
    test("List x = [1,2,2]; switch(x) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("List x = [1,2,2]; switch(x) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("List x = [1,'abc','abc']; switch(x) { [1,int i,_] -> i; default -> 7 }", 7);
    test("List x = [1,2,'abc']; switch(x) { [1,int i,i] -> i; default -> 7 }", 7);
    testError("List x = [1,2,2]; switch(x) { [1,int i,int i] -> i; [1,4,3] -> 7 }", "'i' already declared");
    testError("List a = [1,2,3]; switch(a) { i -> i; [1,4,3] -> 7 }", "unreachable switch case");
    testError("List a = [1,2,3]; switch(a) { List i -> i; [1,4,3] -> 7 }", "unreachable switch case");
    test("List a = [1,2,3]; switch(a) { i -> i }", Utils.listOf(1,2,3));
    testError("List a = [1,2,3]; switch(a) { int i -> i }", "type of binding variable not compatible");
    test("List a = [1,2,3]; switch(a) { List i -> i }", Utils.listOf(1,2,3));
    testError("List a = [1,2,3]; switch(a) { List a -> a }", "binding variable 'a' shadows another variable");
    test("List a = [1,2,3]; switch(a) { def i -> i }", Utils.listOf(1,2,3));
    test("List a = [1,2,3]; switch(a.size()) { int i -> i }", 3);
    testError("List a = [1,2,3]; switch(a.size()) { long i -> i }", "can never match type long");
    testError("List a = [1,2,3]; switch(a) { [1,i,3] -> i; [1,4,3] -> 7 }", "covered by a previous");
    test("List a = [1,2,3]; switch(a) { [1,i,3] -> i; [1,3] -> 7 }", 2);
    test("List a = [1,2,3]; switch(a) { [1,int i,3] -> i; [1,3] -> 7 }", 2);
    test("List a = [1,2,3]; switch(a) { [1,def i,3] -> i; [1,3] -> 7 }", 2);
    test("List a = [1,2,2]; switch(a) { [1,i,i] -> i; [1,4,3] -> 7 }", 2);
    test("List a = [1,2,2]; switch(a) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("List a = [1,2,2]; switch(a) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("List a = [1,'abc','abc']; switch(a) { [1,int i,_] -> i; default -> 7 }", 7);
    test("List a = [1,2,'abc']; switch(a) { [1,int i,i] -> i; default -> 7 }", 7);
    testError("List a = [1,2,2]; switch(a) { [1,int i,int i] -> i; [1,4,3] -> 7 }", "'i' already declared");
    test("def a = [1,2,3]; switch(a) { i -> i }", Utils.listOf(1,2,3));
    test("def a = [1,2,3]; switch(a) { int i -> i; default -> 5 }", 5);
    test("def a = [1,2,3]; switch(a) { List i -> i }", Utils.listOf(1,2,3));
    test("def a = [1,2,3]; switch(a) { def i -> i }", Utils.listOf(1,2,3));
    test("def a = [1,2,3]; switch(a.size()) { int i -> i }", 3);
    test("def a = [1,2,3]; switch(a.size()) { long i -> i; int j -> j*j }", 9);
    test("def a = [1,2,3]; switch(a) { [1,i,3] -> i; [1,3] -> 7 }", 2);
    test("def a = [1,2,3]; switch(a) { [1,int i,3] -> i; [1,3] -> 7 }", 2);
    test("def a = [1,2,2]; switch(a) { [1,i,i] -> i; [1,3] -> 7 }", 2);
    test("def a = [1,2,2]; switch(a) { [1,int i,i] -> i; [1,3] -> 7 }", 2);
    test("def a = [1,2,2]; switch(a) { [1,int i,i] -> i; [1,3] -> 7 }", 2);
    test("def a = [1,'abc','abc']; switch(a) { [1,int i,_] -> i; default -> 7 }", 7);
    test("def a = [1,2,'abc']; switch(a) { [1,int i,i] -> i; default -> 7 }", 7);
    testError("def a = [1,2,2]; switch(a) { [1,int i,int i] -> i; [1,4,3] -> 7 }", "'i' already declared");
    test("def a = [1,2,3,2]; switch(a) { [_,z,_,z] -> z }", 2);
    test("def a = [1,2,3,[4,5,[2,7]]]; switch(a) { [_,x,_,[*,[x,y]]] -> y }", 7);
    test("def a = [1,2,3,[4,5,[2,7]]]; switch(a) { [_,x,_,[*,[x,int y]]] -> y }", 7);
    test("def a = [1,[2,[3,4],2],3,[4,5,[2,[3,4]]]]; switch(a) { [_,[x,List y,x],_,[*,[x,y]]] -> y }", Utils.listOf(3,4));
    test("def a = [1,[2,[3,4],2],3,[4,5,[2,[3,4]]]]; switch(a) { [_,[x,y,x],_,[*,[x,y]]] -> y }", Utils.listOf(3,4));
    test("List a = ['aa','bb','cc']; switch(a) { List i -> i }", Utils.listOf("aa","bb","cc"));
    test("List a = ['aa','bb','cc']; switch(a) { def i -> i }", Utils.listOf("aa","bb","cc"));
    test("List a = ['aa','bb','cc']; switch(a.size()) { int i -> i }", 3);
    testError("List a = ['aa','bb','cc']; switch(a.size()) { long i -> i }", "can never match type long");
    test("List a = ['aa','bb','cc']; switch(a) { ['aa',i,'cc'] -> i; [4,'cc'] -> 7 }", "bb");
    test("List a = ['aa','bb','cc']; switch(a) { ['aa',String i,'cc'] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("List a = ['aa','bb','cc']; switch(a) { ['aa',def i,'cc'] -> i; ['aa','cc'] -> 7 }", "bb");
    test("List a = ['aa','bb','bb']; switch(a) { ['aa',i,i] -> i; ['aa','cc'] -> 7 }", "bb");
    test("List a = ['aa','bb','bb']; switch(a) { ['aa',String i,i] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("List a = ['aa','bb','bb']; switch(a) { ['aa',String i,i] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("List a = ['aa',2,'abc']; switch(a) { ['aa',String i,_] -> i; default -> 7 }", 7);
    test("List a = ['aa','bb','abc']; switch(a) { ['aa',String i,i] -> i; default -> 7 }", 7);
    testError("List a = ['aa','bb','bb']; switch(a) { ['aa',String i,String i] -> i; ['aa',4,'cc'] -> 7 }", "'i' already declared");
    test("List a = ['aa','bb','cc','bb']; switch(a) { [_,x,_,x] -> x }", "bb");
    test("def a = ['aa','bb','cc']; switch(a) { i -> i }", Utils.listOf("aa","bb","cc"));
    test("def a = ['aa','bb','cc']; switch(a) { String i -> i; default -> 5 }", 5);
    test("def a = ['aa','bb','cc']; switch(a) { List i -> i }", Utils.listOf("aa","bb","cc"));
    test("def a = ['aa','bb','cc']; switch(a) { def i -> i }", Utils.listOf("aa","bb","cc"));
    test("def a = ['aa','bb','cc']; switch(a.size()) { String i -> i; int i -> i }", 3);
    test("def a = ['aa','bb','cc']; switch(a.size()) { long i -> i; String j -> j; int i -> i*i }", 9);
    test("def a = ['aa','bb','cc']; switch(a) { ['aa',i,'cc'] -> i; ['aa','cc'] -> 7 }", "bb");
    test("def a = ['aa','bb','cc']; switch(a) { ['aa',String i,'cc'] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("def a = ['aa','bb','bb']; switch(a) { ['aa',i,i] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("def a = ['aa','bb','bb']; switch(a) { ['aa',String i,i] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("def a = ['aa','bb','bb']; switch(a) { ['aa',String i,i] -> i; ['aa',4,'cc'] -> 7 }", "bb");
    test("def a = ['aa','abc','abc']; switch(a) { ['aa',int i,_] -> i; default -> 7 }", 7);
    test("def a = ['aa','bb','abc']; switch(a) { ['aa',String i,i] -> i; default -> 7 }", 7);
    test("def a = ['aa','bb','bb']; switch(a) { ['aa',String i,i] -> i; default -> 7 }", "bb");
    testError("def a = ['aa','bb','bb']; switch(a) { ['aa',String i,String i] -> i; ['aa',4,'cc'] -> 7 }", "'i' already declared");
    test("def a = ['aa','bb','cc','bb']; switch(a) { [_,x,_,x] -> x }", "bb");
    test("def a = ['aa','bb','cc',[4,5,['bb',7]]]; switch(a) { [_,x,_,[*,[x,y]]] -> y }", 7);
    test("def a = ['aa','bb','cc',[4,5,['bb',7]]]; switch(a) { [_,x,_,[*,[x,int y]]] -> y }", 7);
    test("def a = ['aa',['bb',['cc',4],'bb'],'cc',[4,5,['bb',['cc',4]]]]; switch(a) { [_,[x,List y,x],_,[*,[x,y]]] -> y }", Utils.listOf("cc",4));
    test("def a = ['aa',['bb',['cc',4],'bb'],'cc',[4,5,['bb',['cc',4]]]]; switch(a) { [_,[x,y,x],_,[*,[x,y]]] -> y }", Utils.listOf("cc",4));
    test("List a = [1,2]; switch(a) { [z],[_,z] -> z; default -> 3 }", 2);
    test("List a = [1,2,3,2]; switch(a) { [z],[_,z,_,z] -> z; default -> 3 }", 2);
    testError("List a = [1,2,3,2]; def x = 1; switch(a) { [z],[_,z,(x+1-1),z] -> z; default -> 3 }", "expect const or regex or type in match case");
    test("List[] x = [[3],[4]]; switch (x) { [[3],[3]] -> 4; [[3],[4]] -> 3; _ -> null }", 3);
    test("List[] x = [[3],[4]]; switch (x) { [_,[3]] -> 4; [[3],_] -> 3; _ -> null }", 3);
    test("List[] x = [[3],[4]]; switch (x) { [_,[3]] -> 3; [[3],a] -> a; _ -> null } == [4]",true);
    test("def x = [[3],[4]] as List[]; switch (x) { [[3],[3]] -> 4; [[3],[4]] -> 3; _ -> null }", 3);
    test("def x = [[3],[4]] as List[]; switch (x) { [[3],[3]] -> 4; [_,[4]] -> 3; _ -> null }", 3);
    test("def x = [[3],[4]] as List[]; switch (x) { [[3],[3]] -> 4; [a,[4]] -> a; _ -> null } == [3]", true);
    testError("List[][] x = [[[3]], [[4]]]; switch (x) { [_,[3]] -> 3; [[3],a] -> a; _ -> null }", "can never match");
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [[[3]],[a]] -> a; _ -> null } == [4]", true);
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [[[3L]],[a]] -> a; _ -> 77 }", 77);
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [[[3D]],[a]] -> a; _ -> 77 }", 77);
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [[[3.0]],[a]] -> a; _ -> 77 }", 77);
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [[[3]],_] -> 4; _ -> null }", 4);
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [_,[a]] -> a; _ -> null } == [4]", true);
    test("List[][] x = [[[3]],[[4]]]; switch (x) { [[_],[[3]]] -> 3; [_,[List a]] -> a; _ -> null } == [4]", true);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [[[3]],[a]] -> a; _ -> null } == [4]", true);
    test("def x = [[[(byte)3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [[[3]],[a]] -> a; _ -> null } == [4]", true);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [[[3L]],[a]] -> a; _ -> 77 }", 77);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [[[3D]],[a]] -> a; _ -> 77 }", 77);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [[[3.0]],[a]] -> a; _ -> 77 }", 77);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [[[3]],_] -> 4; _ -> null }", 4);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [_,[a]] -> a; _ -> null } == [4]", true);
    test("def x = [[[3]],[[4]]] as List[][]; switch (x) { [[_],[[3]]] -> 3; [_,[List a]] -> a; _ -> null } == [4]", true);
    test("List[] x = [[3,7],[4,9]]; switch (x) { [[3,*],[3,*]] -> 4; [[3,*],[4,*]] -> 3; _ -> null }", 3);
    test("List[] x = [[3,7],[4,9]]; switch (x) { [_,[3,*]] -> 4; [[3,*],_] -> 3; _ -> null }", 3);
    test("List[] x = [[3,7],[4,9]]; switch (x) { [_,[3,*]] -> 3; [[3,*],a] -> a; _ -> null } == [4,9]",true);
    test("def x = [[3,7],[4,9]] as List[]; switch (x) { [[3,*],[3,*]] -> 4; [[3,*],[4,*]] -> 3; _ -> null }", 3);
    test("def x = [[3,7],[4,9]] as List[]; switch (x) { [[3,*],[3,*]] -> 4; [_,[4,*]] -> 3; _ -> null }", 3);
    test("def x = [[3,7],[4,9]] as List[]; switch (x) { [[3,*],[3,*]] -> 4; [a,[4,*]] -> a; _ -> null } == [3,7]", true);
    testError("List[][] x = [[[3,7]], [[4,9]]]; switch (x) { [_,[3,*]] -> 3; [[3,*],a] -> a; _ -> null }", "can never match");
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [[[3,*]],[a]] -> a; _ -> null } == [4,9]", true);
    test("List[][] x = [[[(byte)3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [[[3,*]],[a]] -> a; _ -> null } == [4,9]", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [[[3L,*]],[a]] -> a; _ -> 77 }", 77);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [[[3D,*]],[a]] -> a; _ -> 77 }", 77);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [[[3.0,*]],[a]] -> a; _ -> 77 }", 77);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [[[3,*]],_] -> 4; _ -> null }", 4);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [_,[a]] -> a; _ -> null } == [4,9]", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,*]]] -> 3; [_,[List a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [[[3,*]],[a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [[[3L,*]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [[[3D,*]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [[[3.0,*]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [[[3,*]],_] -> 4; _ -> null }", 4);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [_,[a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,*]]] -> 3; [_,[List a]] -> a; _ -> null } == [4,9]", true);
    test("List[] x = [[3,7],[4,9]]; switch (x) { [[3,7],[3,7]] -> 4; [[3,7],[4,9]] -> 3; _ -> null }", 3);
    test("List[] x = [[3,7],[4,9]]; switch (x) { [_,[3,7]] -> 4; [[3,7],_] -> 3; _ -> null }", 3);
    test("List[] x = [[3,7],[4,9]]; switch (x) { [_,[3,7]] -> 3; [[3,7],a] -> a; _ -> null } == [4,9]",true);
    test("def x = [[3,7],[4,9]] as List[]; switch (x) { [[3,7],[3,7]] -> 4; [[3,7],[4,9]] -> 3; _ -> null }", 3);
    test("def x = [[3,7],[4,9]] as List[]; switch (x) { [[3,7],[3,7]] -> 4; [_,[4,9]] -> 3; _ -> null }", 3);
    test("def x = [[3,7],[4,9]] as List[]; switch (x) { [[3,7],[3,7]] -> 4; [a,[4,9]] -> a; _ -> null } == [3,7]", true);
    testError("List[][] x = [[[3,7]], [[4,9]]]; switch (x) { [_,[3,7]] -> 3; [[3,7],a] -> a; _ -> null }", "can never match");
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3,7]],[a]] -> a; _ -> null } == [4,9]", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3L,7]],[a]] -> a; _ -> null } == null", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3D,7]],[a]] -> a; _ -> null } == null", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3.0,7]],[a]] -> a; _ -> null } == null", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3,7]],_] -> 4; _ -> null }", 4);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [_,[a]] -> a; _ -> null } == [4,9]", true);
    test("List[][] x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [_,[List a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [[[3,7]],[a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [[[3L,7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [[[3D,7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [[[3.0,7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [[[3,7]],_] -> 4; _ -> null }", 4);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [_,[a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]] as List[][]; switch (x) { [[_],[[3,7]]] -> 3; [_,[List a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3,7]],[a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3L,7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3D,7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3.0,7]],[a]] -> a; _ -> null } == null", true);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [[[3,7]],_] -> 4; _ -> null }", 4);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [_,[a]] -> a; _ -> null } == [4,9]", true);
    test("def x = [[[3,7]],[[4,9]]]; switch (x) { [[_],[[3,7]]] -> 3; [_,[List a]] -> a; _ -> null } == [4,9]", true);
  }

  @Test public void switchArrays() {
    test("def x = [1,2,3] as int[]; switch(x) { i -> i }", new int[]{ 1,2,3 });
    test("def x = [1,2,3] as int[]; switch(x) { int i -> i; default -> 5 }", 5);
    test("def x = [1,2,3] as int[]; switch(x) { List i -> i; _ -> 7 }", 7);
    test("def x = [1,2,3] as int[]; switch(x) { List i -> 4; int[] -> 5; _ -> 7 }", 5);
    test("def x = [1,2,3] as int[]; switch(x) { List i -> 4; int[] i -> i; _ -> 7 }", new int[]{ 1,2,3 });
    test("def x = [1,2,3] as int[]; switch(x) { def i -> i }", new int[]{ 1,2,3 });
    test("def x = [1,2,3] as int[]; switch(x.size()) { int i -> i }", 3);
    test("def x = [1,2,3] as int[]; switch(x.size()) { long i -> i; int j -> j*j }", 9);
    test("def x = [1,2,3] as int[]; switch(x) { [1,i,3] -> i; [1,3] -> 7 }", 2);
    test("def x = [1,2,3] as int[]; switch(x) { [1,int i,3] -> i; [1,3] -> 7 }", 2);
    test("def x = [1,2,2] as int[]; switch(x) { [1,i,i] -> i; [1,4,3] -> 7 }", 2);
    test("def x = [1,2,2] as int[]; switch(x) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("def x = [1,2,2] as int[]; switch(x) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("int[] x = [1,2,3] as int[]; switch(x) { i -> i }", new int[]{ 1,2,3 });
    testError("int[] x = [1,2,3] as int[]; switch(x) { int i -> i; default -> 5 }", "not compatible");
    test("int[] x = [1,2,3] as int[]; switch(x) { int[] i -> i }", new int[]{ 1,2,3 });
    test("int[] x = [1,2,3] as int[]; switch(x) { def i -> i }", new int[]{ 1,2,3 });
    test("int[] x = [1,2,3] as int[]; switch(x.size()) { int i -> i }", 3);
    testError("int[] x = [1,2,3] as int[]; switch(x.size()) { long i -> i; int j -> j*j }", "can never match type long");
    test("int[] x = [1,2,3] as int[]; switch(x) { [1,i,3] -> i; [1,3] -> 7 }", 2);
    test("int[] x = [1,2,3] as int[]; switch(x) { [1,int i,3] -> i; [1,3] -> 7 }", 2);
    test("int[] x = [1,2,2] as int[]; switch(x) { [1,i,i] -> i; [1,4,3] -> 7 }", 2);
    test("int[] x = [1,2,2] as int[]; switch(x) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("int[] x = [1,2,2] as int[]; switch(x) { [1,int i,i] -> i; [1,4,3] -> 7 }", 2);
    test("int[][] x = [[1],[1,2,3],[4],[4]]; switch(x) { [_,j,[int i],[i]] -> ((j as List) + i) as int[]; _ -> 7 }", new int[]{ 1,2,3,4 });
    test("def x = [[1],[1,2,3],[4],[4]] as int[][]; switch(x) { [_,j,[int i],[i]] -> ((j as List) + i) as int[]; [1,4,3] -> 7 }", new int[]{ 1,2,3,4 });
    test("def x = [[1],[1,2,3],[4],[4]] as int[][]; switch(x) { [_,[_,j,_],[int i],[i]] -> j+i; [1,4,3] -> 7 }", 6);
    test("int[] x = [1,2,3]; switch (x) { [1,2],[1,2,4] -> 1; [1,2,3] -> 2 }", 2);
  }

  @Test public void switchOnClassTypes() {
    test("class X{}; X x = new X(); switch(x) { X -> 1 }", 1);
    testError("class X{}; X x = new X(); switch(x) { X -> 1; int -> 2 }", "can never match type int");
    testError("class X{}; X x = new X(); switch(x) { X -> 1; def -> 2 }", "unreachable switch case");
    testError("class X{}; X x = new X(); switch(x) { def -> 2; X -> 1 }",  "unreachable switch case");
    test("class X{}; def x = new X(); switch(x) { X -> 1; int -> 2 }", 1);
    test("class X{}; def x = new X(); switch(x) { X -> 1; def -> 2 }", 1);
    testError("class X{}; def x = new X(); switch(x) { def -> 2; X -> 1 }",  "unreachable switch case");
    test("class X{int i}; def x = new X(3); switch(x) { X xxx -> xxx.i; def -> 2 }", 3);
    test("class X{int i}; class Y extends X{}; def x = new Y(3); switch(x) { X xxx -> xxx.i; def -> 2 }", 3);
    test("class X{int i}; class Y extends X{}; def x = new X(3); switch(x) { X xxx -> xxx.i; def -> 2 }", 3);
    test("class X{int i}; class Y extends X{}; def x = new X(3); switch(x) { Y xxx -> xxx.i; def -> 2 }", 2);
    testError("class X{int i}; class Y extends X{}; def x = new X(3); switch(x) { X xxx -> xxx.i; Y -> 2 }", "unreachable switch case");
  }

  @Test public void switchExprWithBlocks() {
    test("List x = [1,2,3]; switch(x) { [1,2],[1,2,3] -> {1}; [1,4,3] -> 2 }", 1);
    test("List x = [1,2,3]; switch(x) { [1,2],[1,2,3] -> { def j = 3; j-2 }; [1,4,3] -> 2 }", 1);
    test("switch(2) { 2 -> { while(0){} }; 3 -> 2 }", null);
    test("switch(1) { 1 -> { switch(2) { 2 -> { while(0){} }; 3 -> 2 } }; 2 -> 3}", null);
    test("switch(1) { 1 -> switch(2) { 2 -> { while(0){} }; 3 -> 2 }; 2 -> 3}", null);
    test("switch(1) { 1 -> sleep(0, switch(2) { 2 -> { while(0){} }; 3 -> 2 }); 2 -> 3}", null);
    test("switch(1) { 1 -> { sleep(0, switch(2) { 2 -> { while(0){} }; 3 -> 2 }) }; 2 -> 3}", null);
    test("switch(1) { 1 -> { switch(2) { 2,4,5 -> { while(sleep(0,0)){} }; 3 -> 2 } }; 2 -> 3}", null);
    test("switch(1) { 1 -> { switch(2) { 2 -> { while(sleep(0,0)){}; sleep(0,4) }; 3 -> 2 } }; 2 -> 3}", 4);
    test("switch(1) { 1 -> { switch(2) { 2 -> { if (false) 1 }; 3 -> 2 } }; 2 -> 3}", null);
    test("switch(1) { 1 -> { switch(2) { 2 -> { if (true) { int x = 1 } }; 3 -> 2 } }; 2 -> 3}", 1);

    doTest("switch(1) { 1 -> { switch(2) { 2 -> { if (false) { int x = 1 } else { 4 } }; default -> 2L } }; 2 -> 3}", 4L, false);
    doTest("switch(1) { 1 -> { switch(2) { 2 -> { if (false) { int x = 1 } else { 4 } }; default -> 2L } }; 2 -> 3}", 4, true);

    test("switch(1) { 1 -> { return 2 }; 2 -> 3 }", 2);
    test("switch(1) { 1 -> { if (true) return 2 }; 2 -> 3 }", 2);
    test("switch(1) { 1 -> { if (false) return 2 }; 2 -> 3 }", null);
    test("int x = 1; x.map{ switch { 0,1,2 -> x.size() }}", Utils.listOf(1));
  }

  @Test public void switchWithIfExpr() {
    test("def a = 7; switch (a) { 1,2,3 -> it; 7 if true -> 11 }", 11);
    test("def a = 7; switch (a) { 1,2,3 -> it; 7 if false -> 11; _ -> 0 }", 0);
    test("def a = 7; switch (a) { 1 if it != 2,2 if it == 2,3 -> it; 7 if it == 3 -> 11; _ -> 0 }", 0);
    test("def a = 7; switch (a) { 1 if it != 2,2 if it == 2,3 -> it; 7 if it == 7 -> 11; _ -> 0 }", 11);
    test("def a = 7; switch (a) { 1 if it != 2,2 if it == 2,3 -> it; 7 if it == sleep(0,7) -> 11; _ -> 0 }", 11);
    test("def a = 'abc'; switch (a) { /a(.*)/r if $1 == 'xx' -> it + $1; /a(.*)/r if $1 == 'bc' -> it + $1*2 }", "abcbcbc");
  }

  @Test public void switchWithClassConstructor() {
    test("class X{ int i }; def x = new X(3); switch (x) { X(3) -> true; _ -> false }", true);
    test("class X{ int i }; X x = new X(3); switch (x) { X(3) -> true; _ -> false }", true);
    test("class X{ long j }; def x = new X(3); switch (x) { X(3) -> true; _ -> false }", true);
    test("class X{ long j }; X x = new X(3); switch (x) { X(3) -> true; _ -> false }", true);
    test("class X{ String s }; def x = new X('abc'); switch (x) { X('abc') -> true; _ -> false }", true);
    test("class X{ String s }; X x = new X('abc'); switch (x) { X('abc') -> true; _ -> false }", true);
    test("class X{ int i; long j }; def x = new X(3,4); switch (x) { X(3,4) -> true; _ -> false }", true);
    test("class X{ int i; long j }; def x = new X(3,4); switch (x) { X(i:3,j:4) -> true; _ -> false }", true);
    test("class X{ int i; long j }; def x = new X(3,4); switch (x) { X(i:_,j:_) -> true; _ -> false }", true);
    test("class X{ int i; long j }; def x = new X(3,4); switch (x) { X(i:_,j:long) -> true; _ -> false }", true);
    test("class X{ int i; long j }; def x = new X(3,4); switch (x) { X(i:_,j:a) -> a; _ -> false }", 4L);
    testError("class X{ int i; long j }; def x = new X(3,4); switch (x) { X() -> true; _ -> false }", "does not match mandatory field count");
    test("class X{ int i=3; long j=4 }; def x = new X(); switch (x) { X() -> true; _ -> false }", true);
    testError("class X{ int i; long j }; def x = new X(3,4); switch (x) { X -> true; X(i:1) -> false }", "covered by a previous");
    testError("class X{ int i; long j }; class Y extends X{int k}; def x = new Y(3,4,5); switch (x) { X(i:1) -> true; Y(i:1) -> false }", "covered by a previous");
    test("class X{ int i; long j }; class Y extends X{int k}; def x = new Y(3,4,5); switch (x) { X(i:2) -> true; Y(i:1) -> false }", null);
    test("class X{ int i; long j }; class Y extends X{int k}; def x = new Y(3,4,5); switch (x) { X(i:2) -> true; Y(i:1) -> false; _ -> 3 }", 3);
    test("class X{ int i; long j }; class Y extends X{int k}; def x = new Y(2,4,5); switch (x) { X(i:2) -> true; Y(i:1) -> false; _ -> 3 }", true);
    test("class X{ int i; long j }; class Y extends X{int k}; def x = new Y(1,4,5); switch (x) { X(i:2) -> true; Y(i:1) -> false; _ -> 3 }", false);
    testError("class X{ int i; long j }; class Y extends X{int k}; def x = new Y(3,4); switch (x) { X(xxx:2) -> true; Y(i:1) -> false }", "xxx does not exist");
    test("class X{int i}; X[] x = [new X(3),new X(4)]; switch (x) { [X(3),X(3)] -> 4; [X(3),X(4)] -> 3; _ -> null }", 3);
    test("class X{int i}; X[] x = [new X(3),new X(4)]; switch (x) { [_,X(3)] -> 4; [X(3),_] -> 3; _ -> null }", 3);
    test("class X{int i}; X[] x = [new X(3),new X(4)]; switch (x) { [_,X(3)] -> 3; [X(3),a] -> a; _ -> null } == new X(4)",true);
    test("class X{int i}; def x = [new X(3),new X(4)] as X[]; switch (x) { [X(3),X(3)] -> 4; [X(3),X(4)] -> 3; _ -> null }", 3);
    test("class X{int i}; def x = [new X(3),new X(4)] as X[]; switch (x) { [X(3),X(3)] -> 4; [_,X(4)] -> 3; _ -> null }", 3);
    test("class X{int i}; def x = [new X(3),new X(4)] as X[]; switch (x) { [X(3),X(3)] -> 4; [a,X(4)] -> a; _ -> null } == new X(3)", true);
    testError("class X{int i}; X[][] x = [[new X(3)], [new X(4)]]; switch (x) { [_,X(3)] -> 3; [X(3),a] -> a; _ -> null }", "can never match");
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [[X(3)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [[X(3L)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [[X(3D)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [[X((Decimal)3)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [[X(3)],_] -> 4; _ -> null }", 4);
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [_,[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; X[][] x = [[new X(3)],[new X(4)]]; switch (x) { [[_],[X(3)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(3)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(3L)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(3D)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X((Decimal)3)],[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(3)],_] -> 4; _ -> null }", 4);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [_,[a]] -> a; _ -> null } == new X(4)", true);
    test("class X{int i}; def x = [[new X(3)],[new X(4)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4)", true);
    testError("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [X(3),X(3)] -> 4; [X(i:3),X(i:4)] -> 3; _ -> null }", "does not match mandatory field count");
    test("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [X(i:3),X(i:3)] -> 4; [X(i:3),X(i:4)] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [_,X(i:3)] -> 4; [X(i:3),_] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [_,X(i:3)] -> 3; [X(i:3),a] -> a; _ -> null } == new X(4,9)",true);
    test("class X{int i;long j}; def x = [new X(3,7),new X(4,9)] as X[]; switch (x) { [X(i:3),X(i:3)] -> 4; [X(i:3),X(i:4)] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; def x = [new X(3,7),new X(4,9)] as X[]; switch (x) { [X(i:3),X(i:3)] -> 4; [_,X(i:4)] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; def x = [new X(3,7),new X(4,9)] as X[]; switch (x) { [X(i:3),X(i:3)] -> 4; [a,X(i:4)] -> a; _ -> null } == new X(3,7)", true);
    testError("class X{int i;long j}; X[][] x = [[new X(3,7)], [new X(4,9)]]; switch (x) { [_,X(i:3)] -> 3; [X(i:3),a] -> a; _ -> null }", "can never match");
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3L)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3D)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:(Decimal)3)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3)],_] -> 4; _ -> null }", 4);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [_,[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3L)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3D)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:(Decimal)3)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [[X(i:3)],_] -> 4; _ -> null }", 4);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [_,[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4,9)", true);
    testError("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [X(3),X(3)] -> 4; [X(i:3,j:7),X(i:3,j:9)] -> 3; _ -> null }", "does not match mandatory field count");
    test("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [X(i:3,j:7),X(i:3,j:7)] -> 4; [X(i:3,j:7),X(i:4,j:9)] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [_,X(i:3,j:7)] -> 4; [X(i:3,j:7),_] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; X[] x = [new X(3,7),new X(4,9)]; switch (x) { [_,X(i:3,j:7)] -> 3; [X(i:3,j:7),a] -> a; _ -> null } == new X(4,9)",true);
    test("class X{int i;long j}; def x = [new X(3,7),new X(4,9)] as X[]; switch (x) { [X(i:3,j:7),X(i:3,j:7)] -> 4; [X(i:3,j:7),X(i:4,j:9)] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; def x = [new X(3,7),new X(4,9)] as X[]; switch (x) { [X(i:3,j:7),X(i:3,j:7)] -> 4; [_,X(i:4,j:9)] -> 3; _ -> null }", 3);
    test("class X{int i;long j}; def x = [new X(3,7),new X(4,9)] as X[]; switch (x) { [X(i:3,j:7),X(i:3,j:7)] -> 4; [a,X(i:4,j:9)] -> a; _ -> null } == new X(3,7)", true);
    testError("class X{int i;long j}; X[][] x = [[new X(3,7)], [new X(4,9)]]; switch (x) { [_,X(i:3,j:7)] -> 3; [X(i:3,j:7),a] -> a; _ -> null }", "can never match");
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3L,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3D,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:(Decimal)3,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3,j:7)],_] -> 4; _ -> null }", 4);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [_,[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; X[][] x = [[new X(3,7)],[new X(4,9)]]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3L,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3D,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:(Decimal)3,j:7)],[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [[X(i:3,j:7)],_] -> 4; _ -> null }", 4);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [_,[a]] -> a; _ -> null } == new X(4,9)", true);
    test("class X{int i;long j}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4,9)", true);
    testError("class X{int i;long j=7}; def x = [[new X(3,7)],[new X(4,9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(4,9)", "too many arguments");
    test("class X{int i;long j=7}; def x = [[new X(3)],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7}; def x = [[new X(i:3,j:7)],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(i:3,j:7)]] -> 3; [_,[X a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7}; def x = [[new X(i:3,j:7)],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(3)],[a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7}; def x = [[new X(i:3,j:7)],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(i:3,j:7)],[a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7}; def x = [[new X(i:3,j:7)],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(i:_,j:7)],[a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7;List list=[]}; def x = [[new X(i:3,j:7,list:[1,2,3])],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(i:_,j:7,list:[1,2,_])],[a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7;List list=[]}; def x = [[new X(i:3,j:7,list:[1,2,3])],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(i:_,j:7,list:[1,2,int b])],[a]] -> a; _ -> null } == new X(i:4,j:9)", true);
    test("class X{int i;long j=7;List list=[]}; def x = [[new X(i:3,j:7,list:[1,2,3])],[new X(i:4,j:9)]] as X[][]; switch (x) { [[_],[X(3)]] -> 3; [[X(i:_,j:long c,list:[1,2,int b])],[a]] -> a.i + a.j + b + c; _ -> null }", 4+9L+7+3);
  }

  @Test public void switchTypeBoolean() {
    test("switch (true) { true -> true; default -> false }", true);
    test("def x = true; switch (x) { 1 -> true; default -> false }", false);
    test("def x = false; switch (x) { 0 -> true; default -> false }", false);
    test("boolean x = true; switch (x) { true -> true; default -> false }", true);
    test("boolean x = true; switch (x) { true -> true; default -> false }", true);
    testError("boolean x = true; switch (x) { 5 -> null; true -> true; default -> false }", "can never match");
    testError("boolean x = false; switch (x) { /abc/r -> null; boolean -> true; default -> false }", "can never match");
    testError("boolean x = false; switch (x) { long -> null; boolean -> true; default -> false }", "can never match");
    testError("boolean x = false; switch (x) { String -> true; default -> false }", "can never match");
    testError("class X{}; boolean x = false; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = (boolean)true; switch (x) { true -> true; default -> false }", true);
    test("def x = (boolean)true; switch (x) { 5 -> null; true -> true; default -> false }", true);
    test("def x = (boolean)false; switch (x) { 5 -> null; true -> true; default -> false }", false);
    test("def x = (boolean)false; switch (x) { long -> null; boolean -> true; default -> false }", true);
    test("def x = (boolean)false; switch (x) { String -> true; default -> false }", false);
    test("class X{}; def x = (boolean)false; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = (boolean)false; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = [(boolean)true]; switch (x) { [true] -> true; default -> false }", true);
    test("List x = [(boolean)true]; switch (x) { [true] -> true; default -> false }", true);
    test("List x = [(boolean)true]; switch (x) { [5] -> null; [true] -> true; default -> false }", true);
    test("List x = [(boolean)true]; switch (x) { [5L] -> null; [true] -> true; default -> false }", true);
    test("List x = [(boolean)false]; switch (x) { [5] -> null; [true] -> true; default -> false }", false);
    test("List x = [(boolean)false]; switch (x) { [long] -> null; [boolean] -> true; default -> false }", true);
    test("List x = [(boolean)false]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; List x = [(boolean)false]; switch (x) { [X]-> true; default -> false }", false);
    test("def x = [(boolean)true]; switch (x) { [true] -> true; default -> false }", true);
    test("def x = [(boolean)true]; switch (x) { [5] -> null; [true] -> true; default -> false }", true);
    test("def x = [(boolean)false]; switch (x) { [5] -> null; [true] -> true; default -> false }", false);
    test("def x = [(boolean)false]; switch (x) { [long] -> null; [boolean] -> true; default -> false }", true);
    test("def x = [(boolean)false]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; def x = [(boolean)false]; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = [false]; switch (x) { [a.b.X] -> true; default -> false }", false);
    test("boolean[] x = [true,false]; switch (x) { [true,true] -> false; [true,false] -> true; _ -> null }", true);
    test("boolean[] x = [true,false]; switch (x) { [_,true] -> false; [true,_] -> true; _ -> null }", true);
    test("boolean[] x = [true,false]; switch (x) { [_,true] -> true; [true,a] -> a; _ -> null }", false);
    test("def x = [true,false] as boolean[]; switch (x) { [true,true] -> false; [true,false] -> true; _ -> null }", true);
    test("def x = [true,false] as boolean[]; switch (x) { [true,true] -> false; [_,false] -> true; _ -> null }", true);
    test("def x = [true,false] as boolean[]; switch (x) { [true,true] -> false; [a,false] -> a; _ -> null }", true);
    testError("boolean[][] x = [[true],[false]]; switch (x) { [_,true] -> true; [true,a] -> a; _ -> null }", "can never match");
    test("boolean[][] x = [[true],[false]]; switch (x) { [[_],[true]] -> true; [[true],[a]] -> a; _ -> null }", false);
    test("boolean[][] x = [[true],[false]]; switch (x) { [[_],[true]] -> true; [[true],_] -> false; _ -> null }", false);
    test("boolean[][] x = [[true],[false]]; switch (x) { [[_],[true]] -> true; [_,[a]] -> a; _ -> null }", false);
    test("boolean[][] x = [[true],[false]]; switch (x) { [[_],[true]] -> true; [_,[boolean a]] -> a; _ -> null }", false);
    test("def x = [[true],[false]] as boolean[][]; switch (x) { [[_],[true]] -> true; [[true],[a]] -> a; _ -> null }", false);
    test("def x = [[true],[false]] as boolean[][]; switch (x) { [[_],[true]] -> true; [[true],_] -> false; _ -> null }", false);
    test("def x = [[true],[false]] as boolean[][]; switch (x) { [[_],[true]] -> true; [_,[a]] -> a; _ -> null }", false);
    test("def x = [[true],[false]] as boolean[][]; switch (x) { [[_],[true]] -> true; [_,[boolean a]] -> a; _ -> null }", false);
  }

  @Test public void switchTypeByte() {
    test("switch ((byte)3) { 3 -> true; default -> false }", true);
    test("switch ((byte)-128) { (byte)-128 -> true; default -> false }", true);
    test("switch ((byte)-128) { 128 -> true; default -> false }", true);
    test("switch ((byte)127) { 127 -> true; default -> false }", true);
    testError("switch ((byte)128) { -1 -> true; default -> false }", "can never match");
    testError("switch ((byte)128) { 256 -> true; default -> false }", "can never match");
    test("byte x = 3; switch (x) { 3 -> true; default -> false }", true);
    testError("byte x = 0; switch (x) { false ->  null; 0 -> true; default -> false }", "can never match");
    testError("byte x = 3; switch (x) { 3L -> true; default -> false }", "can never match");
    test("byte x = -3; switch (x) { 5 -> null; (byte)-3 -> true; default -> false }", true);
    test("const byte x = -3; switch (x) { 5 -> null; (byte)-3 -> true; default -> false }", true);
    testError("byte x = 4; switch (x) { /abc/r -> null; byte -> true; default -> false }", "can never match");
    testError("byte x = 4; switch (x) { long -> null; byte -> true; default -> false }", "can never match");
    testError("byte x = 4; switch (x) { String -> true; default -> false }", "can never match");
    testError("class X{}; byte x = 4; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = (byte)3; switch (x) { true -> 1; 3 -> true; default -> 2 }", true);
    test("def x = (byte)0; switch (x) { false -> null; 3 -> true; default -> false }", false);
    test("def x = (byte)3; switch (x) { 3 -> true; default -> false }", true);
    test("def x = (byte)-3; switch (x) { (byte)-3 -> true; default -> false }", true);
    test("def x = (byte)3; switch (x) { 5 -> null; 3 -> true; default -> false }", true);
    test("def x = (byte)4; switch (x) { 5 -> null; 3 -> true; default -> false }", false);
    test("def x = (byte)4; switch (x) { long -> null; byte -> true; default -> false }", true);
    test("def x = (byte)4; switch (x) { String -> true; default -> false }", false);
    test("class X{}; def x = (byte)4; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = (byte)4; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = [(byte)3]; switch (x) { [3] -> true; default -> false }", true);
    test("List x = [(byte)3]; switch (x) { [3L] -> true; default -> false }", false);
    test("List x = [(byte)3]; switch (x) { [5] -> null; [3] -> true; default -> false }", true);
    test("List x = [(byte)3]; switch (x) { [5L] -> null; [3L] -> true; default -> false }", false);
    test("List x = [(byte)4]; switch (x) { [5] -> null; [3L] -> true; default -> false }", false);
    test("List x = [(byte)4]; switch (x) { [long] -> null; [byte] -> true; default -> false }", true);
    test("List x = [(byte)4]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; List x = [(byte)4]; switch (x) { [X]-> true; default -> false }", false);
    test("def x = [(byte)3]; switch (x) { [3] -> true; default -> false }", true);
    test("def x = [(byte)3]; switch (x) { [true] -> null; [3] -> true; default -> false }", true);
    test("def x = [(byte)4]; switch (x) { [true] -> null; [3] -> true; default -> false }", false);
    test("def x = [(byte)4]; switch (x) { [long] -> null; [byte] -> true; default -> false }", true);
    test("def x = [(byte)4]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; def x = [(byte)4]; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = [4]; switch (x) { [a.b.X] -> true; default -> false }", false);
    test("byte[] x = [3,4]; switch (x) { [3,3] -> 4; [3,4] -> 3; _ -> null }", 3);
    test("byte[] x = [3,4]; switch (x) { [_,3] -> 4; [3,_] -> 3; _ -> null }", 3);
    test("byte[] x = [3,4]; switch (x) { [_,3] -> 3; [3,a] -> a; _ -> null }", (byte)4);
    test("def x = [3,4] as byte[]; switch (x) { [3,3] -> 4; [3,4] -> 3; _ -> null }", 3);
    test("def x = [3,4] as byte[]; switch (x) { [3,3] -> 4; [_,4] -> 3; _ -> null }", 3);
    test("def x = [3,4] as byte[]; switch (x) { [3,3] -> 4; [a,4] -> a; _ -> null }", (byte)3);
    testError("byte[][] x = [[3],[4]]; switch (x) { [_,3] -> 3; [3,a] -> a; _ -> null }", "can never match");
    test("byte[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3],[a]] -> a; _ -> null }", (byte)4);
    test("byte[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3],_] -> 4; _ -> null }", 4);
    test("byte[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [_,[a]] -> a; _ -> null }", (byte)4);
    test("byte[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [_,[byte a]] -> a; _ -> null }", (byte)4);
    test("def x = [[3],[4]] as byte[][]; switch (x) { [[_],[3]] -> 3; [[3],[a]] -> a; _ -> null }", (byte)4);
    test("def x = [[3],[4]] as byte[][]; switch (x) { [[_],[3]] -> 3; [[3],_] -> 4; _ -> null }", 4);
    test("def x = [[3],[4]] as byte[][]; switch (x) { [[_],[3]] -> 3; [_,[a]] -> a; _ -> null }", (byte)4);
    test("def x = [[3],[4]] as byte[][]; switch (x) { [[_],[3]] -> 3; [_,[byte a]] -> a; _ -> null }", (byte)4);
    test("def x = [[3],[4]] as byte[][]; switch (x) { [[_],[3]] -> 3; [[a],*] -> a; _ -> null }", (byte)3);
    test("def x = [[3],[4]] as byte[][]; switch (x) { [[_],[3]] -> 3; [[_],*,[a]] -> a; _ -> null }", (byte)4);
  }

  @Test public void switchTypeInt() {
    test("switch (3) { 3 -> true; default -> false }", true);
    test("int x = 3; switch (x) { 3 -> true; default -> false }", true);
    testError("int x = 3; switch (x) { 3L -> true; default -> false }", "can never match");
    test("int x = 3; switch (x) { 5 -> null; 3 -> true; default -> false }", true);
    test("int x = 3; switch (x) { 5 -> null; 3 -> true; default -> false }", true);
    test("int x = 4; switch (x) { 5 -> null; 3 -> true; default -> false }", false);
    testError("int x = 4; switch (x) { /abc/r -> null; int -> true; default -> false }", "can never match");
    testError("int x = 4; switch (x) { long -> null; int -> true; default -> false }", "can never match");
    testError("int x = 4; switch (x) { String -> true; default -> false }", "can never match");
    testError("class X{}; int x = 4; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = 3; switch (x) { 3 -> true; default -> false }", true);
    test("def x = 3; switch (x) { 5 -> null; 3 -> true; default -> false }", true);
    test("def x = 4; switch (x) { 5 -> null; 3 -> true; default -> false }", false);
    test("def x = 4; switch (x) { long -> null; int -> true; default -> false }", true);
    test("def x = 4; switch (x) { String -> true; default -> false }", false);
    test("class X{}; def x = 4; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = 4; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = [3]; switch (x) { [3] -> true; default -> false }", true);
    test("List x = [3]; switch (x) { [3L] -> false; [3] -> true; default -> false }", true);
    test("List x = [3]; switch (x) { [5] -> null; [3] -> true; default -> false }", true);
    test("List x = [3]; switch (x) { [5L] -> null; [3L] -> true; default -> false }", false);
    test("List x = [4]; switch (x) { [5] -> null; [3L] -> true; default -> false }", false);
    test("List x = [4]; switch (x) { [long] -> null; [int] -> true; default -> false }", true);
    test("List x = [4]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; List x = [4]; switch (x) { [X]-> true; default -> false }", false);
    test("def x = [3]; switch (x) { [3] -> true; default -> false }", true);
    test("def x = [3]; switch (x) { [5] -> null; [3] -> true; default -> false }", true);
    test("def x = [4]; switch (x) { [5] -> null; [3] -> true; default -> false }", false);
    test("def x = [4]; switch (x) { [long] -> null; [int] -> true; default -> false }", true);
    test("def x = [4]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; def x = [4]; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = [4]; switch (x) { [a.b.X] -> true; default -> false }", false);
    test("int[] x = [3,4]; switch (x) { [3,3] -> 4; [3,4] -> 3; _ -> null }", 3);
    test("int[] x = [3,4]; switch (x) { [_,3] -> 4; [3,_] -> 3; _ -> null }", 3);
    test("int[] x = [3,4]; switch (x) { [_,3] -> 3; [3,a] -> a; _ -> null }", (int)4);
    test("def x = [3,4] as int[]; switch (x) { [3,3] -> 4; [3,4] -> 3; _ -> null }", 3);
    test("def x = [3,4] as int[]; switch (x) { [3,3] -> 4; [_,4] -> 3; _ -> null }", 3);
    test("def x = [3,4] as int[]; switch (x) { [3,3] -> 4; [a,4] -> a; _ -> null }", (int)3);
    testError("int[][] x = [[3],[4]]; switch (x) { [_,3] -> 3; [3,a] -> a; _ -> null }", "can never match");
    test("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3],[a]] -> a; _ -> null }", (int)4);
    testError("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3L],[a]] -> a; _ -> null }", "can never match");
    testError("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3D],[a]] -> a; _ -> null }", "can never match");
    testError("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3.0],[a]] -> a; _ -> null }", "can never match");
    test("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [[3],_] -> 4; _ -> null }", 4);
    test("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [_,[a]] -> a; _ -> null }", (int)4);
    test("int[][] x = [[3],[4]]; switch (x) { [[_],[3]] -> 3; [_,[int a]] -> a; _ -> null }", (int)4);
    testError("int[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3; [_,[int a]] -> a; _ -> null }", "can never match");
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [[3],[a]] -> a; _ -> null }", (int)4);
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [[3L],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [[3D],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [[3.0],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [[3],_] -> 4; _ -> null }", 4);
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [_,[a]] -> a; _ -> null }", (int)4);
    test("def x = [[3],[4]] as int[][]; switch (x) { [[_],[3]] -> 3; [_,[int a]] -> a; _ -> null }", (int)4);
  }

  @Test public void switchTypeLong() {
    test("switch (3) { 3 -> true; default -> false }", true);
    testError("long x = 3; switch (x) { 3 -> true; default -> false }", "can never match");
    test("long x = 3; switch (x) { 3L -> true; default -> false }", true);
    test("long x = 3; switch (x) { 5L -> null; 3L -> true; default -> false }", true);
    test("long x = 4; switch (x) { 5L -> null; 3L -> true; default -> false }", false);
    testError("long x = 4; switch (x) { /abc/r -> null; int -> true; default -> false }", "can never match");
    testError("long x = 4; switch (x) { long -> null; int -> true; default -> false }", "can never match");
    testError("long x = 4; switch (x) { String -> true; default -> false }", "can never match");
    testError("class X{}; long x = 4; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = 3L; switch (x) { 3L -> true; default -> false }", true);
    test("def x = 3L; switch (x) { 5L -> null; 3L -> true; default -> false }", true);
    test("def x = 4L; switch (x) { 5 -> null; 3 -> true; default -> false }", false);
    test("def x = 4L; switch (x) { long -> true; int -> null; default -> false }", true);
    test("def x = 4L; switch (x) { String -> true; default -> false }", false);
    test("class X{}; def x = 4L; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = 4L; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = [3L]; switch (x) { [3] -> true; default -> false }", false);
    test("List x = [3L]; switch (x) { [3L] -> true; default -> false }", true);
    test("List x = [3L]; switch (x) { [5] -> null; [3L] -> true; default -> false }", true);
    test("List x = [3L]; switch (x) { [5L] -> null; [3L] -> true; default -> false }", true);
    test("List x = [4L]; switch (x) { [5] -> null; [3L] -> true; default -> false }", false);
    test("List x = [4L]; switch (x) { [long] -> true; [int] -> null; default -> false }", true);
    test("List x = [4L]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; List x = [4L]; switch (x) { [X]-> true; default -> false }", false);
    test("def x = [3L]; switch (x) { [3L] -> true; default -> false }", true);
    test("def x = [3L]; switch (x) { [5] -> null; [3L] -> true; default -> false }", true);
    test("def x = [3L]; switch (x) { [5] -> null; [3] -> true; default -> false }", false);
    test("def x = [4L]; switch (x) { [5] -> null; [3L] -> true; default -> false }", false);
    test("def x = [4L]; switch (x) { [long] -> true; [int] -> null; default -> false }", true);
    test("def x = [4L]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; def x = [4L]; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = [4L]; switch (x) { [a.b.X] -> true; default -> false }", false);
    testError("long[] x = [3,4]; switch (x) { [3,3] -> 4; [3,4] -> 3; _ -> null }", "can never match");
    testError("long[] x = [3,4]; switch (x) { [_,3] -> 4; [3,_] -> 3; _ -> null }", "can never match");
    test("long[] x = [3,4]; switch (x) { [3L,3L] -> 4L; [3L,4L] -> 3L; _ -> null }", 3L);
    test("long[] x = [3,4]; switch (x) { [_,3L] -> 4L; [3L,_] -> 3L; _ -> null }", 3L);
    test("long[] x = [3,4]; switch (x) { [_,3L] -> 3L; [3L,a] -> a; _ -> null }", (long)4);
    test("def x = [3,4] as long[]; switch (x) { [3L,3L] -> 4L; [3L,4L] -> 3L; _ -> null }", 3L);
    test("def x = [3,4] as long[]; switch (x) { [3L,3L] -> 4L; [_,4L] -> 3L; _ -> null }", 3L);
    test("def x = [3,4] as long[]; switch (x) { [3L,3L] -> 4L; [a,4L] -> a; _ -> null }", (long)3L);
    testError("long[][] x = [[3],[4]]; switch (x) { [_,3L] -> 3L; [3L,a] -> a; _ -> null }", "can never match");
    test("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [[3L],[a]] -> a; _ -> null }", (long)4);
    testError("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [[3],[a]] -> a; _ -> null }", "can never match");
    testError("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [[3D],[a]] -> a; _ -> null }", "can never match");
    testError("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [[3.0],[a]] -> a; _ -> null }", "can never match");
    test("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [[3L],_] -> 4L; _ -> null }", 4L);
    test("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [_,[a]] -> a; _ -> null }", (long)4);
    test("long[][] x = [[3],[4]]; switch (x) { [[_],[3L]] -> 3L; [_,[long a]] -> a; _ -> null }", (long)4);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [[3L],[a]] -> a; _ -> null }", (long)4);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [[3],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [[3D],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [[3.0],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [[3L],_] -> 4L; _ -> null }", 4L);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [_,[a]] -> a; _ -> null }", (long)4);
    test("def x = [[3],[4]] as long[][]; switch (x) { [[_],[3L]] -> 3L; [_,[long a]] -> a; _ -> null }", (long)4);
  }

  @Test public void switchTypeDouble() {
    testError("switch (3.0D) { 3 -> true; default -> false }", "can never match");
    testError("switch (3.0D) { 3.0 -> true; default -> false }", "can never match");
    testError("switch (3.0D) { 3L -> true; default -> false }", "can never match");
    test("switch (3.0D) { 3.0D -> true; default -> false }", true);
    test("double x = 3; switch (x) { 3.0D -> true; default -> false }", true);
    testError("double x = 3; switch (x) { 3 -> true; default -> false }", "can never match");
    testError("double x = 3; switch (x) { 3L -> true; default -> false }", "can never match");
    testError("double x = 3; switch (x) { 3.0 -> true; default -> false }", "can never match");
    test("double x = 3.0D; switch (x) { 5D -> null; 3D -> true; default -> false }", true);
    test("double x = 4; switch (x) { 5D -> null; 3.0D -> true; default -> false }", false);
    testError("double x = 4; switch (x) { /abc/r -> null; int -> true; default -> false }", "can never match");
    testError("double x = 4; switch (x) { double -> null; int -> true; default -> false }", "can never match");
    testError("double x = 4; switch (x) { String -> true; default -> false }", "can never match");
    testError("class X{}; double x = 4; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = 3.0D; switch (x) { 3D -> true; default -> false }", true);
    test("def x = 3.0D; switch (x) { 5D -> null; 3.0D -> true; default -> false }", true);
    test("def x = 4.0D; switch (x) { 5D -> null; 3D -> true; default -> false }", false);
    test("def x = 4.0D; switch (x) { double -> true; int -> null; default -> false }", true);
    test("def x = 4.0D; switch (x) { String -> true; default -> false }", false);
    test("class X{}; def x = 4.0D; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = 4.0D; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = [3.0D]; switch (x) { [3] -> true; default -> false }", false);
    test("List x = [3.0D]; switch (x) { [3.0D] -> true; default -> false }", true);
    test("List x = [3.0D]; switch (x) { [5] -> null; [3.0D] -> true; default -> false }", true);
    test("List x = [3.0D]; switch (x) { [5L] -> null; [3.0D] -> true; default -> false }", true);
    test("List x = [4.0D]; switch (x) { [5] -> null; [3.0D] -> true; default -> false }", false);
    test("List x = [4.0D]; switch (x) { [double] -> true; [int] -> null; default -> false }", true);
    test("List x = [4.0D]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; List x = [4.0D]; switch (x) { [X]-> true; default -> false }", false);
    test("def x = [3.0D]; switch (x) { [3.0D] -> true; default -> false }", true);
    test("def x = [3.0D]; switch (x) { [5] -> null; [3] -> true; default -> false }", false);
    test("def x = [4.0D]; switch (x) { [5] -> null; [3.0D] -> true; default -> false }", false);
    test("def x = [4.0D]; switch (x) { [double] -> true; [int] -> null; default -> false }", true);
    test("def x = [4.0D]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; def x = [4.0D]; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = [4.0D]; switch (x) { [a.b.X] -> true; default -> false }", false);
    test("def x = [3,4] as double[]; switch (x) { [3.0D,3.0D] -> 4.0D; [3.0D,4.0D] -> 3.0D; _ -> null }", 3.0D);
    test("def x = [3,4] as double[]; switch (x) { [3.0D,3.0D] -> 4.0D; [_,4.0D] -> 3.0D; _ -> null }", 3.0D);
    test("def x = [3,4] as double[]; switch (x) { [3.0D,3.0D] -> 4.0D; [a,4.0D] -> a; _ -> null }", (double)3.0D);
    testError("double[][] x = [[3],[4]]; switch (x) { [_,3.0D] -> 3.0D; [3.0D,a] -> a; _ -> null }", "can never match");
    test("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3.0D],[a]] -> a; _ -> null }", (double)4);
    testError("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3],[a]] -> a; _ -> null }", "can never match");
    testError("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3L],[a]] -> a; _ -> null }", "can never match");
    testError("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3.0],[a]] -> a; _ -> null }", "can never match");
    test("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3.0D],_] -> 4.0D; _ -> null }", 4.0D);
    test("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [_,[a]] -> a; _ -> null }", (double)4);
    test("double[][] x = [[3],[4]]; switch (x) { [[_],[3.0D]] -> 3.0D; [_,[double a]] -> a; _ -> null }", (double)4);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3.0D],[a]] -> a; _ -> null }", (double)4);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3L],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3.0],[a]] -> a; _ -> null }", null);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [[3.0D],_] -> 4.0D; _ -> null }", 4.0D);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [_,[a]] -> a; _ -> null }", (double)4);
    test("def x = [[3],[4]] as double[][]; switch (x) { [[_],[3.0D]] -> 3.0D; [_,[double a]] -> a; _ -> null }", (double)4);
  }

  @Test public void switchTypeDecimal() {
    testError("switch (3.0) { 3 -> true; default -> false }", "can never match");
    testError("switch (3.0) { 3L -> true; default -> false }", "can never match");
    testError("switch (3.0) { 3D -> true; default -> false }", "can never match");
    test("switch (3.0) { 3.0 -> true; default -> false }", true);
    test("Decimal x = 3; switch (x) { (Decimal)3 -> true; default -> false }", true);
    testError("Decimal x = 3; switch (x) { 3L -> true; default -> false }", "can never match");
    test("Decimal x = 3.0; switch (x) { 5.0 -> null; 3.0 -> true; default -> false }", true);
    test("Decimal x = 4; switch (x) { 5.0 -> null; 3.0 -> true; default -> false }", false);
    testError("Decimal x = 4; switch (x) { /abc/r -> null; int -> true; default -> false }", "can never match");
    testError("Decimal x = 4; switch (x) { Decimal -> null; int -> true; default -> false }", "can never match");
    testError("Decimal x = 4; switch (x) { String -> true; default -> false }", "can never match");
    testError("class X{}; Decimal x = 4; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = 3.0; switch (x) { 3 -> true; default -> false }", false);
    test("def x = 3.0; switch (x) { 3.0 -> true; default -> false }", true);
    test("def x = 3.0; switch (x) { 5.0 -> null; 3.0 -> true; default -> false }", true);
    test("def x = 4.0; switch (x) { 5.0 -> null; 3.0 -> true; default -> false }", false);
    test("def x = 4.0; switch (x) { Decimal -> true; int -> null; default -> false }", true);
    test("def x = 4.0; switch (x) { String -> true; default -> false }", false);
    test("class X{}; def x = 4.0; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = 4.0; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = [3.0]; switch (x) { [3] -> true; default -> false }", false);
    test("List x = [3.0]; switch (x) { [3.0] -> true; default -> false }", true);
    test("List x = [3.0]; switch (x) { [5] -> null; [3.0] -> true; default -> false }", true);
    test("List x = [3.0]; switch (x) { [5L] -> null; [3.0] -> true; default -> false }", true);
    test("List x = [4.0]; switch (x) { [5] -> null; [3.0] -> true; default -> false }", false);
    test("List x = [4.0]; switch (x) { [Decimal] -> true; [int] -> null; default -> false }", true);
    test("List x = [4.0]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; List x = [4.0]; switch (x) { [X]-> true; default -> false }", false);
    test("def x = [3.0]; switch (x) { [3.0] -> true; default -> false }", true);
    test("def x = [3 as Decimal]; switch (x) { [5] -> null; [(Decimal)3] -> true; default -> false }", true);
    test("def x = [4.0]; switch (x) { [5] -> null; [3.0] -> true; default -> false }", false);
    test("def x = [4.0]; switch (x) { [Decimal] -> true; [int] -> null; default -> false }", true);
    test("def x = [4.0]; switch (x) { [String] -> true; default -> false }", false);
    test("class X{}; def x = [4.0]; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = [4.0]; switch (x) { [a.b.X] -> true; default -> false }", false);
    test("Decimal[] x = [3,4]; switch (x) { [(Decimal)3,(Decimal)3] -> 4; [(Decimal)3,(Decimal)4] -> 3; _ -> null }", 3);
    test("Decimal[] x = [3,4]; switch (x) { [_,(Decimal)3] -> 4; [(Decimal)3,_] -> 3; _ -> null }", 3);
    test("Decimal[] x = [3,4]; switch (x) { [_,(Decimal)3] -> 3; [(Decimal)3,a] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("def x = [3,4] as Decimal[]; switch (x) { [(Decimal)3,(Decimal)3] -> 4; [(Decimal)3,(Decimal)4] -> 3; _ -> null }", 3);
    test("def x = [3,4] as Decimal[]; switch (x) { [(Decimal)3,(Decimal)3] -> 4; [_,(Decimal)4] -> 3; _ -> null }", 3);
    test("def x = [3,4] as Decimal[]; switch (x) { [(Decimal)3,(Decimal)3] -> 4; [a,(Decimal)4] -> a; _ -> null }", BigDecimal.valueOf(3));
    testError("Decimal[][] x = [[3],[4]]; switch (x) { [_,(Decimal)3] -> 3; [(Decimal)3,a] -> a; _ -> null }", "can never match");
    test("Decimal[][] x = [[3],[4]]; switch (x) { [[_],[(Decimal)3]] -> 3; [[(Decimal)3],[a]] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("Decimal[][] x = [[3],[4]]; switch (x) { [[_],[(Decimal)3]] -> 3; [[(Decimal)3],_] -> 4; _ -> null }", 4);
    test("Decimal[][] x = [[3],[4]]; switch (x) { [[_],[(Decimal)3]] -> 3; [_,[a]] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("Decimal[][] x = [[3],[4]]; switch (x) { [[_],[(Decimal)3]] -> 3; [_,[Decimal a]] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("def x = [[3],[4]] as Decimal[][]; switch (x) { [[_],[(Decimal)3]] -> 3; [[(Decimal)3],[a]] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("def x = [[3],[4]] as Decimal[][]; switch (x) { [[_],[(Decimal)3]] -> 3; [[(Decimal)3],_] -> 4; _ -> null }", 4);
    test("def x = [[3],[4]] as Decimal[][]; switch (x) { [[_],[(Decimal)3]] -> 3; [_,[a]] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("def x = [[3],[4]] as Decimal[][]; switch (x) { [[_],[(Decimal)3]] -> 3; [_,[Decimal a]] -> a; _ -> null }", BigDecimal.valueOf(4));
    test("Decimal[] x = [3.0,4.0]; switch (x) { [(Decimal)3.0D,(Decimal)3.0D] -> 4.0D; [(Decimal)3D,(Decimal)4D] -> 3.0D; _ -> null }", 3.0D);
    test("Decimal[] x = [3,4]; switch (x) { [(Decimal)3L,(Decimal)3L] -> 4.0D; [(Decimal)3L,(Decimal)4L] -> 3.0D; _ -> null }", 3.0D);
  }

  @Test public void switchTypeString() {
    test("switch ('abc') { 'abc' -> true; default -> false }", true);
    test("String x = 'abc'; switch (x) { 'abc' -> true; default -> false }", true);
    test("String x = 'abc'; switch (x) { 'abc' -> true; default -> false }", true);
    test("String x = 'abc'; switch (x) { '5' -> null; 'abc' -> true; default -> false }", true);
    test("String x = 'xyz'; switch (x) { '5' -> null; 'abc' -> true; default -> false }", false);
    testError("String x = 'xyz'; switch (x) { /abc/r -> null; int -> true; default -> false }", "can never match");
    testError("String x = 'xyz'; switch (x) { String -> null; int -> true; default -> false }", "can never match");
    testError("String x = 'xyz'; switch (x) { Decimal -> true; default -> false }", "can never match");
    testError("class X{}; String x = 'xyz'; switch (x) { X -> true; default -> false }", "can never match");
    test("def x = 'abc'; switch (x) { 'abc' -> true; default -> false }", true);
    test("def x = 'abc'; switch (x) { 'xxx' -> null; 'abc' -> true; default -> false }", true);
    test("def x = 'xyz'; switch (x) { 'xxx' -> null; 'abc' -> true; default -> false }", false);
    test("def x = 'xyz'; switch (x) { String -> true; int -> null; default -> false }", true);
    test("def x = 'xyz'; switch (x) { int -> true; default -> false }", false);
    test("class X{}; def x = 'xyz'; switch (x) { X -> true; default -> false }", false);
    test("package a.b; class X{}; def x = 'xyz'; switch (x) { a.b.X -> true; default -> false }", false);
    test("List x = ['abc']; switch (x) { ['abc'] -> true; default -> false }", true);
    test("List x = ['abc']; switch (x) { ['abc'] -> true; default -> false }", true);
    test("List x = ['abc']; switch (x) { ['xxx'] -> null; ['abc'] -> true; default -> false }", true);
    test("List x = ['abc']; switch (x) { ['xxx'] -> null; ['abc'] -> true; default -> false }", true);
    test("List x = ['xyz']; switch (x) { ['xxx'] -> null; ['abc'] -> true; default -> false }", false);
    test("List x = ['xyz']; switch (x) { [String] -> true; [int] -> null; default -> false }", true);
    test("List x = ['xyz']; switch (x) { [int] -> true; default -> false }", false);
    test("class X{}; List x = ['xyz']; switch (x) { [X]-> true; default -> false }", false);
    test("def x = ['abc']; switch (x) { ['abc'] -> true; default -> false }", true);
    test("def x = ['abc']; switch (x) { ['xxx'] -> null; ['abc'] -> true; default -> false }", true);
    test("def x = ['xyz']; switch (x) { ['xxx'] -> null; ['abc'] -> true; default -> false }", false);
    test("def x = ['xyz']; switch (x) { [String] -> true; [int] -> null; default -> false }", true);
    test("def x = ['xyz']; switch (x) { [int] -> true; default -> false }", false);
    test("class X{}; def x = ['xyz']; switch (x) { [X] -> true; default -> false }", false);
    test("package a.b; class X{}; def x = ['xyz']; switch (x) { [a.b.X] -> true; default -> false }", false);
    test("String[] x = ['3','4']; switch (x) { ['3','3'] -> '4'; ['3','4'] -> '3'; _ -> null }", "3");
    test("String[] x = ['3','4']; switch (x) { [_,'3'] -> '4'; ['3',_] -> '3'; _ -> null }", "3");
    test("String[] x = ['3','4']; switch (x) { [_,'3'] -> '3'; ['3',a] -> a; _ -> null }", "4");
    test("def x = ['3','4'] as String[]; switch (x) { ['3','3'] -> '4'; ['3','4'] -> '3'; _ -> null }", "3");
    test("def x = ['3','4'] as String[]; switch (x) { ['3','3'] -> '4'; [_,'4'] -> '3'; _ -> null }", "3");
    test("def x = ['3','4'] as String[]; switch (x) { ['3','3'] -> '4'; [a,'4'] -> a; _ -> null }", "3");
    testError("String[][] x = [['3'],['4']]; switch (x) { [_,'3'] -> '3'; ['3',a] -> a; _ -> null }", "can never match");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [['3'],[a]] -> a; _ -> null }", "4");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [['3'],_] -> '4'; _ -> null }", "4");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [_,[a]] -> a; _ -> null }", "4");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [_,[String a]] -> a; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [['3'],[a]] -> a; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [['3'],_] -> '4'; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [_,[a]] -> a; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [_,[String a]] -> a; _ -> null }", "4");
    test("String[] x = ['3','4']; switch (x) { ['3','3'] -> '4'; ['3','4'] -> '3'; _ -> null }", "3");
    test("String[] x = ['3','4']; switch (x) { [_,'3'] -> '4'; ['3',_] -> '3'; _ -> null }", "3");
    test("String[] x = ['3','4']; switch (x) { [_,'3'] -> '3'; ['3',a] -> a; _ -> null }", "4");
    test("def x = ['3','4'] as String[]; switch (x) { ['3','3'] -> '4'; ['3','4'] -> '3'; _ -> null }", "3");
    test("def x = ['3','4'] as String[]; switch (x) { ['3','3'] -> '4'; [_,'4'] -> '3'; _ -> null }", "3");
    test("def x = ['3','4'] as String[]; switch (x) { ['3','3'] -> '4'; [a,'4'] -> a; _ -> null }", "3");
    testError("String[][] x = [['3'],['4']]; switch (x) { [_,'3'] -> '3'; ['3',a] -> a; _ -> null }", "can never match");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [['3'],[a]] -> a; _ -> null }", "4");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [['3'],_] -> '4'; _ -> null }", "4");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [_,[a]] -> a; _ -> null }", "4");
    test("String[][] x = [['3'],['4']]; switch (x) { [[_],['3']] -> '3'; [_,[String a]] -> a; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [['3'],[a]] -> a; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [['3'],_] -> '4'; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [_,[a]] -> a; _ -> null }", "4");
    test("def x = [['3'],['4']] as String[][]; switch (x) { [[_],['3']] -> '3'; [_,[String a]] -> a; _ -> null }", "4");
  }

  @Test public void switchConstants() {
    test("class X { const int A=1, B=2, C=3 }; int x = 2; switch (x) { X.A -> 'a'; X.B -> 'b'; X.C -> 'c' }", "b");
    test("package a.b.c; class X { const int A=1, B=2, C=3 }; int x = 2; switch (x) { a.b.c.X.A -> 'a'; X.B -> 'b'; X.C -> 'c' }", "b");
    test(Utils.listOf("package a.b.c; class X { const int A=1, B=2, C=3 }"), "package a.b.c; int x = 2; switch (x) { a.b.c.X.A -> 'a'; X.B -> 'b'; X.C -> 'c' }", "b");
    test(Utils.listOf("package a.b.c; class X { const int A=1, B=2, C=3 }"), "import a.b.c.X; int x = 2; switch (x) { X.A -> 'a'; X.B -> 'b'; X.C -> 'c' }", "b");
    test(Utils.listOf("package a.b.c; class X { const int A=1, B=2, C=3 }"), "import static a.b.c.X.*; int x = 2; switch (x) { A -> 'a'; B -> 'b'; C -> 'c' }", "b");
    test(Utils.listOf("package a.b.c; class X { const int A=1, B=2, C=3 }"),
         "import static a.b.c.X.A as a; import static a.b.c.X.B as B; import a.b.c.X;\n" +
         "int x = 2; switch (x) { a -> 'a'; B -> 'b'; X.C -> 'c' }", "b");
    testError("class X { const int A=1, B=2, C=3 }; int x = 2; switch (x) { X.A() -> 'a'; X.B -> 'b'; X.C -> 'c' }", "unknown class");
    test("class X { const int a=1, b=2, c=3 }; int x = 2; switch (x) { X.a -> 'a'; X.b -> 'b'; X.c -> 'c' }", "b");
    test("const x = 2; switch(2) { x -> true }", true);
    test("const X = 2; switch(2) { X -> true }", true);
    test("def f() { const x = 2; switch(2) { x -> true } }; f()", true);
    test("def f() { const X = 2; switch(2) { X -> true } }; f()", true);
    test("const x = 2; def f() { switch(2) { x -> true } }; f()", true);
    test("const X = 2; def f() { switch(2) { X -> true } }; f()", true);
  }
}
