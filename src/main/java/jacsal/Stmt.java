/*
 * Copyright 2022 James Crawford
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package jacsal;

////////////////////////////////////////////////////////////////////
// File was generated using GenerateClasses.pl in tools directory
// DO NOT EDIT THIS FILE
////////////////////////////////////////////////////////////////////


import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

/**
 * Stmt classes for our AST.
 */
abstract class Stmt {

  abstract <T> T accept(Visitor<T> visitor);


  Token      location = null;

  /**
   * Each script is parsed into a Script object. This is true even if the script
   * is just a declaration of a class (or classes) and there are no actual statements
   * to execute outside of the class declaration.
   */
  static class Script extends Stmt {
    FunDecl function;
    Script(FunDecl function) {
      this.function = function;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitScript(this); }
    @Override public String toString() { return "Script[" + "function=" + function + "]"; }
  }

  /**
   * Represents a sequence of statments.
   */
  static class Stmts extends Stmt {
    List<Stmt> stmts = new ArrayList<>();
    Stmts() {
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitStmts(this); }
    @Override public String toString() { return "Stmts[" + "stmts=" + stmts + "]"; }
  }

  /**
   * Represents a block of statments. This class represents a scope for any variables
   * declared by statements within the block.
   */
  static class Block extends Stmt {
    Token openBrace;
    Stmts stmts;
    Map<String,Expr.VarDecl> variables = new HashMap<>();
    int slotsUsed = 0;   // How many local var slots used by vars in this block
    Block(Token openBrace, Stmts stmts) {
      this.openBrace = openBrace;
      this.stmts = stmts;
      this.location = openBrace;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitBlock(this); }
    @Override public String toString() { return "Block[" + "openBrace=" + openBrace + ", " + "stmts=" + stmts + ", " + "variables=" + variables + "]"; }
  }

  /**
   * If statement with condition and statement(s) to execute if true
   * and statement(s) to execute if false.
   */
  static class If extends Stmt {
    Token ifToken;
    Expr condtion;
    Stmt trueStmt;
    Stmt falseStmt;
    If(Token ifToken, Expr condtion, Stmt trueStmt, Stmt falseStmt) {
      this.ifToken = ifToken;
      this.condtion = condtion;
      this.trueStmt = trueStmt;
      this.falseStmt = falseStmt;
      this.location = ifToken;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitIf(this); }
    @Override public String toString() { return "If[" + "ifToken=" + ifToken + ", " + "condtion=" + condtion + ", " + "trueStmt=" + trueStmt + ", " + "falseStmt=" + falseStmt + "]"; }
  }

  /**
   * Variable declaration with optional initialiser. Statement wraps the corresponding
   * Expr type where the work is done.
   */
  static class VarDecl extends Stmt {
    Token typeToken;
    Expr.VarDecl declExpr;
    VarDecl(Token typeToken, Expr.VarDecl declExpr) {
      this.typeToken = typeToken;
      this.declExpr = declExpr;
      this.location = typeToken;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitVarDecl(this); }
    @Override public String toString() { return "VarDecl[" + "typeToken=" + typeToken + ", " + "declExpr=" + declExpr + "]"; }
  }

  /**
   * Function declaration
   */
  static class FunDecl extends Stmt {
    Token      name;
    JacsalType returnType;
    Block      block;
    int        slotIdx;          // Current slot available for allocation
    int        maxSlot;          // Maximum slot used for local vars
    boolean    returnValue;      // Value used as implicit return from function
    FunDecl(Token name, JacsalType returnType) {
      this.name = name;
      this.returnType = returnType;
      this.location = name;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitFunDecl(this); }
    @Override public String toString() { return "FunDecl[" + "name=" + name + ", " + "returnType=" + returnType + ", " + "block=" + block + "]"; }
  }

  /**
   * Return statement
   */
  static class Return extends Stmt {
    Token      returnToken;
    Expr       expr;
    JacsalType returnType;      // Return type of the function we are embedded in
    Return(Token returnToken, Expr expr, JacsalType returnType) {
      this.returnToken = returnToken;
      this.expr = expr;
      this.returnType = returnType;
      this.location = returnToken;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitReturn(this); }
    @Override public String toString() { return "Return[" + "returnToken=" + returnToken + ", " + "expr=" + expr + ", " + "returnType=" + returnType + "]"; }
  }

  /**
   * Statements that are just an expression. This can be used, for example, where there
   * is an expression at the end of a function without having to exlicitly have the "return"
   * keyword to indicate that the expression is the return value of the function.
   * Other types of statements that are just an expression include simple assignments. Since
   * an assignment has a value (the value being assigned), an assignment is actually an expression.
   */
  static class ExprStmt extends Stmt {
    Token exprLocation;
    Expr expr;
    ExprStmt(Token exprLocation, Expr expr) {
      this.exprLocation = exprLocation;
      this.expr = expr;
      this.location = exprLocation;
    }
    @Override <T> T accept(Visitor<T> visitor) { return visitor.visitExprStmt(this); }
    @Override public String toString() { return "ExprStmt[" + "exprLocation=" + exprLocation + ", " + "expr=" + expr + "]"; }
  }

  interface Visitor<T> {
    T visitScript(Script stmt);
    T visitStmts(Stmts stmt);
    T visitBlock(Block stmt);
    T visitIf(If stmt);
    T visitVarDecl(VarDecl stmt);
    T visitFunDecl(FunDecl stmt);
    T visitReturn(Return stmt);
    T visitExprStmt(ExprStmt stmt);
  }
}
