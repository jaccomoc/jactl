/*
 * Copyright 2022 James Crawford
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package io.jactl;

////////////////////////////////////////////////////////////////////
// File was generated using GenerateClasses.pl in tools directory
// DO NOT EDIT THIS FILE
////////////////////////////////////////////////////////////////////


import java.util.List;
import java.util.ArrayList;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.HashSet;

import io.jactl.Token;
import io.jactl.runtime.ClassDescriptor;
import org.objectweb.asm.Label;

/**
 * Stmt classes for our AST.
 */
public abstract class Stmt {

  public abstract <T> T accept(Visitor<T> visitor);


  public Token      location   = null;
  public boolean    isResolved = false;
  public boolean    isAsync    = false;   // Whether statement contains an async call

  /**
   * Represents a sequence of statments.
   */
  public static class Stmts extends Stmt {
    public Token token;
    public List<Stmt> stmts = new ArrayList<>();

    public int currentIdx;     // Which statement we are currently resolving
    public Stmts(Token token) {
      this.token = token;
      this.location = token;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitStmts(this); }
    @Override public String toString() { return "Stmts[" + "token=" + token + "]"; }
  }

  /**
   * Represents a block of statments. This class represents a scope for any variables
   * declared by statements within the block.
   */
  public static class Block extends Stmt {
    public Token                    openBrace;
    public Stmts                    stmts;
    public List<Stmt.FunDecl>       functions    = new ArrayList<>();

    public Map<String,Expr.VarDecl> variables  = new LinkedHashMap<>();

    public boolean isBeginBlock;
    public boolean isEndBlock;

    // Used to track which Stmt.Stmts we are currently resolving in case we need to insert a new statement
    // at Resolve time
    public Stmt.Stmts               currentResolvingStmts;

    public boolean isResolvingParams = false;   // Used during resolution to tell if we are resolving function/closure
                                          // parameters so we can tell when we need to convert a declared parameter
                                          // into one that is passed as a HeapLocal (because it is closed over by
                                          // an initialiser for another parameter of the same function).
    public Block(Token openBrace, Stmts stmts) {
      this.openBrace = openBrace;
      this.stmts = stmts;
      this.location = openBrace;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitBlock(this); }
    @Override public String toString() { return "Block[" + "openBrace=" + openBrace + ", " + "stmts=" + stmts + "]"; }
  }

  /**
   * If statement with condition and statement(s) to execute if true
   * and statement(s) to execute if false.
   */
  public static class If extends Stmt {
    public Token ifToken;
    public Expr  condition;
    public Stmt  trueStmt;
    public Stmt  falseStmt;
    public If(Token ifToken, Expr condition, Stmt trueStmt, Stmt falseStmt) {
      this.ifToken = ifToken;
      this.condition = condition;
      this.trueStmt = trueStmt;
      this.falseStmt = falseStmt;
      this.location = ifToken;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitIf(this); }
    @Override public String toString() { return "If[" + "ifToken=" + ifToken + ", " + "condition=" + condition + ", " + "trueStmt=" + trueStmt + ", " + "falseStmt=" + falseStmt + "]"; }
  }

  /**
   * Class declaration
   */
  public static class ClassDecl extends Stmt {
    public Token                name;
    public String               packageName;
    public Token                baseClassToken;
    public JactlType           baseClass;
    public boolean              isInterface;
    public List<Stmt.Import>    imports;
    public Stmt.Block           classBlock;
    public List<Stmt.FunDecl>   methods = new ArrayList<>();
    public Stmt.FunDecl         initMethod;
    public List<Stmt.ClassDecl> innerClasses = new ArrayList<>();

    public List<List<Expr>>     interfaces = new ArrayList<>();

    public Stmt.FunDecl             scriptMain;                         // Mainline of script
    public List<Stmt.VarDecl>       fields    = new ArrayList<>();      // Field VarDecl stmts
    public Map<String,Expr.VarDecl> fieldVars = new LinkedHashMap<>();  // Map of field name to decl expr
    public Expr.VarDecl             thisField;
    public Set<Object>              classConstants = new HashSet();     // Constants to be initialised in class init

    // Used by Parser and Resolver
    public Deque<Expr.FunDecl>      nestedFunctions = new ArrayDeque<>();

    public ClassDescriptor classDescriptor;

    public boolean isScriptClass() { return scriptMain != null; }
    public ClassDecl(Token name, String packageName, Token baseClassToken, JactlType baseClass, boolean isInterface) {
      this.name = name;
      this.packageName = packageName;
      this.baseClassToken = baseClassToken;
      this.baseClass = baseClass;
      this.isInterface = isInterface;
      this.location = name;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitClassDecl(this); }
    @Override public String toString() { return "ClassDecl[" + "name=" + name + ", " + "packageName=" + packageName + ", " + "baseClassToken=" + baseClassToken + ", " + "baseClass=" + baseClass + ", " + "isInterface=" + isInterface + "]"; }
  }

  /**
   * Import statement
   */
  public static class Import extends Stmt {
    public Token      token;
    public List<Expr> className;
    public Token      as;
    public boolean    staticImport;
    public Import(Token token, List<Expr> className, Token as, boolean staticImport) {
      this.token = token;
      this.className = className;
      this.as = as;
      this.staticImport = staticImport;
      this.location = token;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitImport(this); }
    @Override public String toString() { return "Import[" + "token=" + token + ", " + "className=" + className + ", " + "as=" + as + ", " + "staticImport=" + staticImport + "]"; }
  }

  /**
   * Variable declaration with optional initialiser. Statement wraps the corresponding
   * Expr type where the work is done.
   */
  public static class VarDecl extends Stmt {
    public Token        name;
    public Expr.VarDecl declExpr;
    public VarDecl(Token name, Expr.VarDecl declExpr) {
      this.name = name;
      this.declExpr = declExpr;
      this.location = name;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitVarDecl(this); }
    @Override public String toString() { return "VarDecl[" + "name=" + name + ", " + "declExpr=" + declExpr + "]"; }
  }

  /**
   * Function declaration
   */
  public static class FunDecl extends Stmt {
    public Token        startToken;   // Either identifier for function decl or start brace for closure
    public Expr.FunDecl declExpr;

    // Create a var that points to MethodHandle (which points to wrapper).
    // Exception is when inside wrapper function we don't create var that points to
    // the function since the MethodHandle must go through the wrapper function.
    public boolean      createVar = true;
    public FunDecl(Token startToken, Expr.FunDecl declExpr) {
      this.startToken = startToken;
      this.declExpr = declExpr;
      this.location = startToken;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitFunDecl(this); }
    @Override public String toString() { return "FunDecl[" + "startToken=" + startToken + ", " + "declExpr=" + declExpr + "]"; }
  }

  /**
   * While, for, and do/until loops
   */
  public static class While extends Stmt {
    public Token whileToken;
    public Expr  condition;
    public Token label;
    public Stmt  body;
    public Stmt  updates;            // used for For loops
    public Label endLoopLabel;       // where to jump to on break stmt
    public Label continueLabel;      // where to jump to on a continue stmt
    public int   stackDepth;         // depth of stack where while loop is (used by continue/break)
    public int   globalRegexMatches; // count of number of /xxx/g in while condition
    public boolean isDoUntil = false;
    public While(Token whileToken, Expr condition, Token label) {
      this.whileToken = whileToken;
      this.condition = condition;
      this.label = label;
      this.location = whileToken;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitWhile(this); }
    @Override public String toString() { return "While[" + "whileToken=" + whileToken + ", " + "condition=" + condition + ", " + "label=" + label + "]"; }
  }

  /**
   * Return statement
   */
  public static class Return extends Stmt {
    public Token       returnToken;
    public Expr.Return expr;
    public Return(Token returnToken, Expr.Return expr) {
      this.returnToken = returnToken;
      this.expr = expr;
      this.location = returnToken;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitReturn(this); }
    @Override public String toString() { return "Return[" + "returnToken=" + returnToken + ", " + "expr=" + expr + "]"; }
  }

  /**
   * Statements that are just an expression. This can be used, for example, where there
   * is an expression at the end of a function without having to exlicitly have the "return"
   * keyword to indicate that the expression is the return value of the function.
   * Other types of statements that are just an expression include simple assignments. Since
   * an assignment has a value (the value being assigned), an assignment is actually an expression.
   */
  public static class ExprStmt extends Stmt {
    public Token exprLocation;
    public Expr expr;
    public ExprStmt(Token exprLocation, Expr expr) {
      this.exprLocation = exprLocation;
      this.expr = expr;
      this.location = exprLocation;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitExprStmt(this); }
    @Override public String toString() { return "ExprStmt[" + "exprLocation=" + exprLocation + ", " + "expr=" + expr + "]"; }
  }

  /**
   * Internal use only - throw RuntimeError
   */
  public static class ThrowError extends Stmt {
    public Token token;
    public Expr.Identifier source;
    public Expr.Identifier offset;
    public String msg;
    public ThrowError(Token token, Expr.Identifier source, Expr.Identifier offset, String msg) {
      this.token = token;
      this.source = source;
      this.offset = offset;
      this.msg = msg;
      this.location = token;
    }
    @Override public <T> T accept(Visitor<T> visitor) { return visitor.visitThrowError(this); }
    @Override public String toString() { return "ThrowError[" + "token=" + token + ", " + "source=" + source + ", " + "offset=" + offset + ", " + "msg=" + msg + "]"; }
  }

  public interface Visitor<T> {
    T visitStmts(Stmts stmt);
    T visitBlock(Block stmt);
    T visitIf(If stmt);
    T visitClassDecl(ClassDecl stmt);
    T visitImport(Import stmt);
    T visitVarDecl(VarDecl stmt);
    T visitFunDecl(FunDecl stmt);
    T visitWhile(While stmt);
    T visitReturn(Return stmt);
    T visitExprStmt(ExprStmt stmt);
    T visitThrowError(ThrowError stmt);
  }
}
